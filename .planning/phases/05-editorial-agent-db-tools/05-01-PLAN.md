---
phase: 05-editorial-agent-db-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/editorial_ai/services/celeb_service.py
  - src/editorial_ai/services/product_service.py
  - src/editorial_ai/prompts/enrich.py
  - tests/test_services.py
autonomous: true

must_haves:
  truths:
    - "search_celebs_multi searches name, name_en, description columns with OR"
    - "search_products_multi searches name, brand, description columns with OR"
    - "Multiple queries are deduplicated by ID"
    - "Empty query list returns empty results without error"
  artifacts:
    - path: "src/editorial_ai/services/celeb_service.py"
      provides: "search_celebs_multi() with or_() multi-column search"
      exports: ["search_celebs_multi"]
    - path: "src/editorial_ai/services/product_service.py"
      provides: "search_products_multi() with or_() multi-column search"
      exports: ["search_products_multi"]
    - path: "src/editorial_ai/prompts/enrich.py"
      provides: "Keyword expansion and content re-generation prompts"
      exports: ["build_keyword_expansion_prompt", "build_enrichment_regeneration_prompt"]
    - path: "tests/test_services.py"
      provides: "Unit tests for new multi-column search functions"
  key_links:
    - from: "src/editorial_ai/services/celeb_service.py"
      to: "supabase client"
      via: "or_() PostgREST filter"
      pattern: "\\.or_\\("
    - from: "src/editorial_ai/services/product_service.py"
      to: "supabase client"
      via: "or_() PostgREST filter"
      pattern: "\\.or_\\("
---

<objective>
Extend celeb/product search services with multi-column OR search and create enrichment prompt templates.

Purpose: Foundation for Phase 5 enrich_editorial node -- multi-column search enables broader matching than single-column ilike, and prompts drive Gemini keyword expansion + content re-generation.
Output: Enhanced search functions in celeb_service.py/product_service.py, new enrich prompts module, unit tests.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-editorial-agent-db-tools/05-RESEARCH.md
@.planning/phases/05-editorial-agent-db-tools/05-CONTEXT.md

@src/editorial_ai/services/celeb_service.py
@src/editorial_ai/services/product_service.py
@src/editorial_ai/models/celeb.py
@src/editorial_ai/models/product.py
@src/editorial_ai/prompts/curation.py
@src/editorial_ai/prompts/editorial.py
@tests/test_services.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend celeb_service and product_service with multi-column OR search</name>
  <files>
    src/editorial_ai/services/celeb_service.py
    src/editorial_ai/services/product_service.py
  </files>
  <action>
Add `search_celebs_multi()` to celeb_service.py and `search_products_multi()` to product_service.py.

**celeb_service.py -- add `search_celebs_multi` and `deduplicate_celebs`:**

```python
async def search_celebs_multi(queries: list[str], *, limit: int = 10) -> list[Celeb]:
    """Search celebs across name, name_en, description for multiple queries.

    Uses Supabase or_() with PostgREST syntax for multi-column ilike matching.
    Results from all queries are deduplicated by ID, preserving first occurrence order.
    """
    if not queries:
        return []
    client = await get_supabase_client()
    all_results: list[Celeb] = []
    for query in queries:
        pattern = f"%{query}%"
        response = await (
            client.table("celebs")
            .select("*")
            .or_(f"name.ilike.{pattern},name_en.ilike.{pattern},description.ilike.{pattern}")
            .limit(limit)
            .execute()
        )
        all_results.extend(Celeb.model_validate(row) for row in response.data)
    return _deduplicate_by_id(all_results)


def _deduplicate_by_id(items: list[Celeb]) -> list[Celeb]:
    """Remove duplicate celebs by ID, preserving first occurrence order."""
    seen: set[str] = set()
    result: list[Celeb] = []
    for item in items:
        if item.id not in seen:
            seen.add(item.id)
            result.append(item)
    return result
```

**product_service.py -- add `search_products_multi` and `_deduplicate_by_id`:**

Same pattern but for products. Search columns: `name`, `brand`, `description` (products don't have name_en).

```python
async def search_products_multi(queries: list[str], *, limit: int = 10) -> list[Product]:
    """Search products across name, brand, description for multiple queries."""
    if not queries:
        return []
    client = await get_supabase_client()
    all_results: list[Product] = []
    for query in queries:
        pattern = f"%{query}%"
        response = await (
            client.table("products")
            .select("*")
            .or_(f"name.ilike.{pattern},brand.ilike.{pattern},description.ilike.{pattern}")
            .limit(limit)
            .execute()
        )
        all_results.extend(Product.model_validate(row) for row in response.data)
    return _deduplicate_by_id(all_results)


def _deduplicate_by_id(items: list[Product]) -> list[Product]:
    seen: set[str] = set()
    result: list[Product] = []
    for item in items:
        if item.id not in seen:
            seen.add(item.id)
            result.append(item)
    return result
```

Keep existing `search_celebs()` and `search_products()` functions intact (backward compat).
  </action>
  <verify>
`uv run python -c "from editorial_ai.services.celeb_service import search_celebs_multi; from editorial_ai.services.product_service import search_products_multi; print('imports OK')"` succeeds.
  </verify>
  <done>
search_celebs_multi and search_products_multi are importable and use or_() for multi-column search. Existing functions unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create enrich prompts module</name>
  <files>
    src/editorial_ai/prompts/enrich.py
  </files>
  <action>
Create `src/editorial_ai/prompts/enrich.py` with two prompt builder functions:

1. **`build_keyword_expansion_prompt(keyword: str) -> str`**: Prompt that instructs Gemini to expand a fashion keyword into 5-10 related search terms in Korean. Must be domain-constrained to fashion/celebrity/brand. Output format: JSON array of strings. Include examples (e.g., 'Y2K' -> ['레트로', '빈티지', '로우라이즈', '크롭탑']).

2. **`build_enrichment_regeneration_prompt(original_content_json: str, celebs_json: str, products_json: str, keyword: str) -> str`**: Prompt for re-generating EditorialContent with real DB celeb/product data. Must:
   - Pass the FULL original EditorialContent JSON as context to preserve quality
   - Instruct Gemini to maintain the original tone, structure, and editorial quality
   - Naturally incorporate celeb/product data into body_paragraphs (not just lists)
   - Update celeb_mentions and product_mentions with names matching DB data
   - Output format: EditorialContent JSON schema
   - Explicitly warn: "Do NOT reduce content quality or make it read like a product catalog"

Follow the pattern in `prompts/curation.py` and `prompts/editorial.py` (pure string-returning functions, no LLM calls).
  </action>
  <verify>
`uv run python -c "from editorial_ai.prompts.enrich import build_keyword_expansion_prompt, build_enrichment_regeneration_prompt; print(build_keyword_expansion_prompt('Y2K')[:100])"` prints prompt text.
  </verify>
  <done>
Two prompt builder functions exist, domain-constrained for fashion, with clear JSON output instructions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for multi-column search and deduplication</name>
  <files>
    tests/test_services.py
  </files>
  <action>
Add tests to `tests/test_services.py` for the new search functions. Follow the existing mock pattern using `_build_mock_client` but add `or_()` support to the builder mock.

Create a helper that extends the existing `_build_mock_client`:

```python
def _build_mock_client_or(response_data: dict | list | None) -> MagicMock:
    """Build mock client with or_() chain support for multi-column search."""
    mock_client = _build_mock_client(response_data)
    builder = mock_client.table.return_value
    builder.or_.return_value = builder  # Add or_ to the chain
    return mock_client
```

**Tests to add (all async, using @patch on get_supabase_client):**

1. `test_search_celebs_multi_returns_results` -- single query returns matching celebs
2. `test_search_celebs_multi_empty_queries` -- empty query list returns []
3. `test_search_celebs_multi_deduplicates` -- same celeb from multiple queries appears once
4. `test_search_products_multi_returns_results` -- single query returns matching products
5. `test_search_products_multi_empty_queries` -- empty query list returns []
6. `test_search_products_multi_deduplicates` -- same product from multiple queries appears once

For deduplication tests: mock execute() to return the same item for two different queries, assert result length is 1.

Import the new functions:
```python
from editorial_ai.services.celeb_service import search_celebs_multi
from editorial_ai.services.product_service import search_products_multi
```
  </action>
  <verify>
`uv run pytest tests/test_services.py -v` -- all tests pass including new ones.
  </verify>
  <done>
6 new tests pass. Multi-column OR search and deduplication verified. Existing tests still pass.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_services.py -v` passes all tests (existing + new)
- `uv run python -c "from editorial_ai.services.celeb_service import search_celebs_multi"` imports OK
- `uv run python -c "from editorial_ai.services.product_service import search_products_multi"` imports OK
- `uv run python -c "from editorial_ai.prompts.enrich import build_keyword_expansion_prompt, build_enrichment_regeneration_prompt"` imports OK
</verification>

<success_criteria>
- search_celebs_multi and search_products_multi use or_() for multi-column search
- Empty query list returns [] without error
- Deduplication by ID works correctly
- Enrich prompts are domain-constrained for fashion and produce clear JSON output instructions
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-editorial-agent-db-tools/05-01-SUMMARY.md`
</output>
