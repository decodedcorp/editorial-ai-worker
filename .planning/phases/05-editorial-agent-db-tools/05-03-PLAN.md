---
phase: 05-editorial-agent-db-tools
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/editorial_ai/nodes/enrich.py
  - src/editorial_ai/nodes/stubs.py
  - src/editorial_ai/graph.py
  - tests/test_enrich_node.py
  - tests/test_graph.py
autonomous: true

must_haves:
  truths:
    - "enrich_editorial node exists between editorial and review in the graph"
    - "Graph topology is editorial -> enrich -> review (not editorial -> review)"
    - "enrich node reads current_draft from state, enriches it, writes back enriched draft"
    - "Pipeline completes successfully with enrich node in the graph"
    - "When current_draft is None, enrich node logs error and passes through"
    - "Existing graph tests updated to reflect new topology"
  artifacts:
    - path: "src/editorial_ai/nodes/enrich.py"
      provides: "enrich_editorial_node LangGraph node function"
      exports: ["enrich_editorial_node"]
      min_lines: 25
    - path: "src/editorial_ai/graph.py"
      provides: "Updated graph with enrich node between editorial and review"
      contains: 'add_edge("editorial", "enrich")'
    - path: "src/editorial_ai/nodes/stubs.py"
      provides: "stub_enrich stub for testing"
      exports: ["stub_enrich"]
    - path: "tests/test_enrich_node.py"
      provides: "Unit tests for enrich node"
    - path: "tests/test_graph.py"
      provides: "Updated graph topology tests"
  key_links:
    - from: "src/editorial_ai/nodes/enrich.py"
      to: "src/editorial_ai/services/enrich_service.py"
      via: "enrich_editorial_content import"
      pattern: "from editorial_ai.services.enrich_service import enrich_editorial_content"
    - from: "src/editorial_ai/graph.py"
      to: "src/editorial_ai/nodes/enrich.py"
      via: "enrich_editorial_node import"
      pattern: "from editorial_ai.nodes.enrich import enrich_editorial_node"
    - from: "src/editorial_ai/graph.py"
      to: "editorial -> enrich -> review edge chain"
      via: "add_edge calls"
      pattern: 'add_edge\\("editorial", "enrich"\\)'
---

<objective>
Create the enrich_editorial LangGraph node and wire it into the graph between editorial and review.

Purpose: This is the final integration step -- the enrich node calls enrich_service to enrich the Phase 4 draft with real DB data, and the graph is updated so the pipeline flows editorial -> enrich -> review.
Output: New enrich node, stub_enrich for testing, updated graph.py edges, updated graph tests.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-editorial-agent-db-tools/05-RESEARCH.md
@.planning/phases/05-editorial-agent-db-tools/05-CONTEXT.md
@.planning/phases/05-editorial-agent-db-tools/05-01-SUMMARY.md
@.planning/phases/05-editorial-agent-db-tools/05-02-SUMMARY.md

@src/editorial_ai/nodes/editorial.py
@src/editorial_ai/nodes/stubs.py
@src/editorial_ai/graph.py
@src/editorial_ai/state.py
@src/editorial_ai/services/enrich_service.py
@src/editorial_ai/models/layout.py
@tests/test_graph.py
@tests/test_editorial_node.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enrich node and stub</name>
  <files>
    src/editorial_ai/nodes/enrich.py
    src/editorial_ai/nodes/stubs.py
  </files>
  <action>
**Create `src/editorial_ai/nodes/enrich.py`:**

Follow the exact pattern of `nodes/editorial.py` -- thin async wrapper around the service:

```python
async def enrich_editorial_node(state: EditorialPipelineState) -> dict:
    """LangGraph node: enrich editorial draft with DB celeb/product data.

    Reads current_draft from state, calls enrich_service to search Supabase
    for matching celebs/products and re-generate content with DB context.
    Writes enriched layout back to current_draft.
    """
    current_draft = state.get("current_draft")
    if not current_draft:
        return {"error_log": ["Enrich skipped: no current_draft in state"]}

    try:
        layout = MagazineLayout.model_validate(current_draft)
        enriched = await enrich_editorial_content(layout)
        return {"current_draft": enriched.model_dump()}
    except Exception as e:
        logger.exception("Enrich node failed")
        return {"error_log": [f"Enrich failed: {type(e).__name__}: {e!s}"]}
```

Key points:
- Import `enrich_editorial_content` from `editorial_ai.services.enrich_service`
- Import `MagazineLayout` from `editorial_ai.models.layout`
- If current_draft is None, log error and return (no crash)
- On exception, log and return error_log (same pattern as editorial_node)
- Do NOT change pipeline_status -- enrich is transparent, status stays as set by editorial_node

**Add `stub_enrich` to `stubs.py`:**

```python
def stub_enrich(state: EditorialPipelineState) -> dict:
    """Stub: Phase 5에서 구현. DB 데이터 enrichment."""
    return {}
```

This stub passes through without modifying state (current_draft stays as-is).
  </action>
  <verify>
`uv run python -c "from editorial_ai.nodes.enrich import enrich_editorial_node; from editorial_ai.nodes.stubs import stub_enrich; print('imports OK')"` succeeds.
  </verify>
  <done>
enrich_editorial_node exists as thin async wrapper around enrich_service. stub_enrich available for testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire enrich node into graph and update all tests</name>
  <files>
    src/editorial_ai/graph.py
    tests/test_graph.py
    tests/test_enrich_node.py
  </files>
  <action>
**Modify `src/editorial_ai/graph.py`:**

1. Add import: `from editorial_ai.nodes.enrich import enrich_editorial_node`
2. Add import: `from editorial_ai.nodes.stubs import stub_enrich` (add to existing stubs import, with `# noqa: F401` comment for backward compat)
3. In `build_graph()`, add "enrich" to the nodes dict:
   ```python
   nodes = {
       "curation": curation_node,
       "source": stub_source,
       "editorial": editorial_node,
       "enrich": enrich_editorial_node,  # Phase 5: DB enrichment
       "review": stub_review,
       "admin_gate": stub_admin_gate,
       "publish": stub_publish,
   }
   ```
4. Change edges: replace `builder.add_edge("editorial", "review")` with:
   ```python
   builder.add_edge("editorial", "enrich")
   builder.add_edge("enrich", "review")
   ```
5. Update the docstring to reflect: `curation -> source -> editorial -> enrich -> review -> admin_gate -> publish`

**Modify `tests/test_graph.py`:**

Update all test functions that use `node_overrides` to include `"enrich": stub_enrich`:

1. `test_graph_happy_path`: Add `"enrich": stub_enrich` to node_overrides
2. `test_graph_review_fail_then_pass`: Add `"enrich": stub_enrich` to node_overrides
3. `test_graph_max_retries`: Add `"enrich": stub_enrich` to node_overrides
4. `test_graph_admin_revision_requested`: Add `"enrich": stub_enrich` to node_overrides

Import `stub_enrich` from stubs:
```python
from editorial_ai.nodes.stubs import stub_curation, stub_editorial, stub_enrich
```

Add a new test:
```python
def test_graph_has_enrich_node():
    """Graph includes enrich node between editorial and review."""
    compiled = build_graph()
    assert "enrich" in compiled.nodes
```

**Create `tests/test_enrich_node.py`:**

Unit tests for the enrich node with mocked enrich_service:

1. `test_enrich_node_no_draft` -- state has current_draft=None, returns error_log entry
2. `test_enrich_node_success` -- mock enrich_editorial_content returning enriched layout, verify current_draft updated
3. `test_enrich_node_service_error` -- mock enrich_editorial_content raising Exception, verify error_log returned (no crash)

Mock strategy: `@patch("editorial_ai.nodes.enrich.enrich_editorial_content")` as `AsyncMock`.
For success test, create a minimal MagazineLayout dict as current_draft in state.
  </action>
  <verify>
`uv run pytest tests/test_graph.py tests/test_enrich_node.py -v` -- all tests pass.
`uv run pytest tests/ -v` -- full test suite passes with no regressions.
  </verify>
  <done>
Graph flows editorial -> enrich -> review. All graph topology tests pass with updated node_overrides. Enrich node unit tests cover: no draft, success, and error cases. Full test suite green.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/ -v` -- full test suite passes
- `uv run python -c "from editorial_ai.graph import build_graph; g = build_graph(); assert 'enrich' in g.nodes; print('enrich node in graph')"` confirms node exists
- Graph docstring reflects updated topology
- No existing tests broken
</verification>

<success_criteria>
- Graph topology: editorial -> enrich -> review (confirmed by test)
- enrich_editorial_node reads current_draft, calls enrich_service, writes enriched draft back
- Graceful handling: no current_draft -> error_log, service exception -> error_log
- All existing graph tests pass with stub_enrich in overrides
- Full test suite green
</success_criteria>

<output>
After completion, create `.planning/phases/05-editorial-agent-db-tools/05-03-SUMMARY.md`
</output>
