---
phase: 05-editorial-agent-db-tools
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/editorial_ai/services/enrich_service.py
  - tests/test_enrich_service.py
autonomous: true

must_haves:
  truths:
    - "Gemini keyword expansion returns fashion-domain related terms"
    - "DB search combines mention names + expanded keywords for broad coverage"
    - "Content is re-generated with real celeb/product data naturally incorporated"
    - "Empty DB results cause graceful passthrough (no error, original content preserved)"
    - "Layout is rebuilt with actual DB IDs in CelebFeatureBlock/ProductShowcaseBlock"
  artifacts:
    - path: "src/editorial_ai/services/enrich_service.py"
      provides: "Enrichment orchestration: keyword expansion, DB search, re-generation, layout rebuild"
      exports: ["enrich_editorial_content"]
      min_lines: 80
    - path: "tests/test_enrich_service.py"
      provides: "Unit tests for enrich service with mocked Gemini + Supabase"
      min_lines: 60
  key_links:
    - from: "src/editorial_ai/services/enrich_service.py"
      to: "src/editorial_ai/services/celeb_service.py"
      via: "search_celebs_multi import"
      pattern: "from editorial_ai.services.celeb_service import search_celebs_multi"
    - from: "src/editorial_ai/services/enrich_service.py"
      to: "src/editorial_ai/services/product_service.py"
      via: "search_products_multi import"
      pattern: "from editorial_ai.services.product_service import search_products_multi"
    - from: "src/editorial_ai/services/enrich_service.py"
      to: "src/editorial_ai/prompts/enrich.py"
      via: "prompt builder imports"
      pattern: "from editorial_ai.prompts.enrich import"
    - from: "src/editorial_ai/services/enrich_service.py"
      to: "google.genai"
      via: "Gemini API for keyword expansion and re-generation"
      pattern: "client.aio.models.generate_content"
---

<objective>
Create the enrich_service that orchestrates keyword expansion, DB search, content re-generation, and layout rebuilding.

Purpose: This is the core business logic for Phase 5 -- it coordinates Gemini keyword expansion with Supabase multi-column search, then re-generates editorial content with real DB data and rebuilds the layout with actual celeb/product IDs.
Output: enrich_service.py with full orchestration logic, comprehensive unit tests.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-editorial-agent-db-tools/05-RESEARCH.md
@.planning/phases/05-editorial-agent-db-tools/05-CONTEXT.md
@.planning/phases/05-editorial-agent-db-tools/05-01-SUMMARY.md

@src/editorial_ai/services/celeb_service.py
@src/editorial_ai/services/product_service.py
@src/editorial_ai/services/curation_service.py
@src/editorial_ai/services/editorial_service.py
@src/editorial_ai/models/editorial.py
@src/editorial_ai/models/layout.py
@src/editorial_ai/models/celeb.py
@src/editorial_ai/models/product.py
@src/editorial_ai/prompts/enrich.py
@src/editorial_ai/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enrich_service.py with full orchestration logic</name>
  <files>
    src/editorial_ai/services/enrich_service.py
  </files>
  <action>
Create `src/editorial_ai/services/enrich_service.py` with the following functions:

**1. `extract_celeb_names(layout: MagazineLayout) -> list[str]`**
Extract celeb names from CelebFeatureBlock blocks in layout.

**2. `extract_product_names(layout: MagazineLayout) -> list[str]`**
Extract product names from ProductShowcaseBlock blocks in layout.

**3. `expand_keywords(client: genai.Client, keyword: str) -> list[str]`**
Use Gemini to expand a keyword into related fashion search terms. Reuse patterns from curation_service:
- Import `retry_on_api_error` and `_strip_markdown_fences` from curation_service
- Use `build_keyword_expansion_prompt` from prompts/enrich
- Parse JSON array response, return list[str]
- On parse error, return empty list (graceful degradation)
- Use `settings.default_model` and temperature=0.3

**4. `regenerate_with_enrichment(client: genai.Client, original: EditorialContent, celebs: list[Celeb], products: list[Product], keyword: str) -> EditorialContent`**
Re-generate editorial content with DB data context:
- Use `build_enrichment_regeneration_prompt` from prompts/enrich
- Serialize original EditorialContent, celebs, products to JSON for the prompt
- Use `settings.editorial_model` (or `settings.default_model` if editorial_model doesn't exist -- check config.py)
- Use `response_mime_type="application/json"` and `response_schema=EditorialContent`
- temperature=0.7
- Wrap with `retry_on_api_error`
- On failure, return original content unchanged (graceful degradation)

**5. `rebuild_layout_with_db_data(layout: MagazineLayout, enriched_content: EditorialContent, celebs: list[Celeb], products: list[Product]) -> MagazineLayout`**
Rebuild layout blocks with real DB IDs:
- deepcopy layout to preserve input immutability (follow editorial_service pattern)
- Build name->model lookup maps (case-insensitive: `.lower()`)
- For CelebFeatureBlock: update celebs list with CelebItem containing celeb_id from DB, profile_image_url, description
- For ProductShowcaseBlock: update products list with ProductItem containing product_id from DB, brand, image_url, description
- For BodyTextBlock: update paragraphs from enriched_content.body_paragraphs
- Return new MagazineLayout

**6. `enrich_editorial_content(layout: MagazineLayout) -> MagazineLayout`**
Top-level orchestration function (called by enrich node):
- Extract mention names from layout
- Get genai client via `get_genai_client()` from curation_service
- Expand keywords
- Combine mention names + expanded keywords as search terms
- Call `search_celebs_multi` and `search_products_multi`
- If both empty, return original layout unchanged (graceful passthrough)
- Regenerate content with DB context
- Rebuild layout with DB IDs
- Return enriched layout

**Imports to use:**
- `from copy import deepcopy`
- `from editorial_ai.services.curation_service import get_genai_client, retry_on_api_error, _strip_markdown_fences`
- `from editorial_ai.services.celeb_service import search_celebs_multi`
- `from editorial_ai.services.product_service import search_products_multi`
- `from editorial_ai.prompts.enrich import build_keyword_expansion_prompt, build_enrichment_regeneration_prompt`
- `from editorial_ai.models.editorial import EditorialContent, CelebMention, ProductMention`
- `from editorial_ai.models.layout import MagazineLayout, CelebFeatureBlock, ProductShowcaseBlock, BodyTextBlock, CelebItem, ProductItem`
- `from editorial_ai.models.celeb import Celeb`
- `from editorial_ai.models.product import Product`
- `from editorial_ai.config import settings`
- `from google.genai import types`
  </action>
  <verify>
`uv run python -c "from editorial_ai.services.enrich_service import enrich_editorial_content, expand_keywords, rebuild_layout_with_db_data; print('imports OK')"` succeeds.
  </verify>
  <done>
enrich_service.py exists with 6 functions covering the full orchestration pipeline: extract mentions, expand keywords, search DB, regenerate content, rebuild layout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for enrich_service</name>
  <files>
    tests/test_enrich_service.py
  </files>
  <action>
Create `tests/test_enrich_service.py` with comprehensive unit tests. All external calls (Gemini, Supabase) must be mocked.

**Test fixtures:**
- `SAMPLE_LAYOUT_DICT`: A minimal MagazineLayout dict with HeroBlock, HeadlineBlock, BodyTextBlock, CelebFeatureBlock (1 celeb with no celeb_id), ProductShowcaseBlock (1 product with no product_id)
- `SAMPLE_CELEB_DB`: A Celeb object with id="celeb-123", name matching the one in layout
- `SAMPLE_PRODUCT_DB`: A Product object with id="prod-456", name matching the one in layout

**Tests to write:**

1. `test_extract_celeb_names` -- extracts names from CelebFeatureBlock
2. `test_extract_product_names` -- extracts names from ProductShowcaseBlock
3. `test_extract_celeb_names_no_blocks` -- layout with no CelebFeatureBlock returns []
4. `test_expand_keywords_success` -- mock Gemini returning JSON array, verify parsed list
5. `test_expand_keywords_parse_error` -- mock Gemini returning garbage, verify returns []
6. `test_rebuild_layout_with_db_data` -- verify celeb_id and product_id are populated from DB lookup
7. `test_rebuild_layout_preserves_input` -- original layout is not mutated (deepcopy check)
8. `test_enrich_editorial_content_no_db_results` -- mock search returning empty, verify original layout returned unchanged
9. `test_enrich_editorial_content_success` -- mock all dependencies (Gemini + Supabase), verify enriched layout has DB IDs

**Mocking strategy:**
- Gemini client: `MagicMock` with `client.aio.models.generate_content` as `AsyncMock` returning mock response with `.text` attribute
- Supabase search: `@patch("editorial_ai.services.enrich_service.search_celebs_multi")` and `search_products_multi` as `AsyncMock`
- get_genai_client: `@patch("editorial_ai.services.enrich_service.get_genai_client")`

Follow existing test file patterns (pytest marks, async tests, descriptive names).
  </action>
  <verify>
`uv run pytest tests/test_enrich_service.py -v` -- all tests pass.
  </verify>
  <done>
9+ tests pass covering: extraction, keyword expansion, layout rebuild, graceful degradation on empty results, and full orchestration flow.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_enrich_service.py -v` -- all tests pass
- `uv run pytest tests/ -v` -- no regressions in existing tests
- `uv run python -c "from editorial_ai.services.enrich_service import enrich_editorial_content"` imports OK
</verification>

<success_criteria>
- enrich_service.py orchestrates: extract mentions -> expand keywords -> search DB -> regenerate -> rebuild layout
- Empty DB results return original layout unchanged (graceful passthrough)
- Layout rebuild populates celeb_id/product_id from DB matches
- Re-generation uses Gemini with full original content as context
- All tests pass with mocked external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/05-editorial-agent-db-tools/05-02-SUMMARY.md`
</output>
