---
phase: 07-admin-backend-hitl
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/editorial_ai/services/content_service.py
  - src/editorial_ai/nodes/admin_gate.py
  - src/editorial_ai/nodes/publish.py
  - supabase/migrations/001_editorial_contents.sql
  - tests/test_content_service.py
autonomous: true

must_haves:
  truths:
    - "Content service can save review-passed content to Supabase as pending"
    - "Content service can update content status (approve, reject, publish)"
    - "Content service can list and retrieve contents by status"
    - "admin_gate node calls interrupt() and returns admin decision on resume"
    - "publish node updates content status to published and sets pipeline_status"
  artifacts:
    - path: "src/editorial_ai/services/content_service.py"
      provides: "Supabase editorial_contents CRUD"
      exports: ["save_pending_content", "update_content_status", "get_content_by_id", "list_contents_by_status", "get_content_by_thread_id"]
    - path: "src/editorial_ai/nodes/admin_gate.py"
      provides: "LangGraph node with interrupt() pattern"
      exports: ["admin_gate"]
    - path: "src/editorial_ai/nodes/publish.py"
      provides: "Publish node that finalizes content"
      exports: ["publish_node"]
    - path: "supabase/migrations/001_editorial_contents.sql"
      provides: "SQL migration for editorial_contents table"
      contains: "CREATE TABLE editorial_contents"
    - path: "tests/test_content_service.py"
      provides: "Unit tests for content CRUD"
  key_links:
    - from: "src/editorial_ai/nodes/admin_gate.py"
      to: "src/editorial_ai/services/content_service.py"
      via: "save_pending_content call before interrupt"
      pattern: "save_pending_content"
    - from: "src/editorial_ai/nodes/publish.py"
      to: "src/editorial_ai/services/content_service.py"
      via: "update_content_status to published"
      pattern: "update_content_status"
---

<objective>
Create the content storage service, admin_gate node with LangGraph interrupt() pattern, and publish node.

Purpose: These are the core building blocks -- content CRUD for Supabase, the interrupt-based admin gate that pauses the pipeline for human approval, and the publish node that finalizes approved content.
Output: content_service.py, admin_gate.py, publish.py, SQL migration, unit tests
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-admin-backend-hitl/07-RESEARCH.md

@src/editorial_ai/state.py
@src/editorial_ai/graph.py
@src/editorial_ai/nodes/stubs.py
@src/editorial_ai/services/supabase_client.py
@src/editorial_ai/config.py
@src/editorial_ai/models/layout.py
@src/editorial_ai/models/review.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Supabase migration + content_service.py</name>
  <files>
    supabase/migrations/001_editorial_contents.sql
    src/editorial_ai/services/content_service.py
    tests/test_content_service.py
  </files>
  <action>
1. Create `supabase/migrations/001_editorial_contents.sql` with the table schema from RESEARCH.md:
   - id UUID PK, thread_id TEXT NOT NULL, status TEXT with CHECK constraint (pending/approved/rejected/published)
   - title TEXT, keyword TEXT, layout_json JSONB, review_summary TEXT, rejection_reason TEXT, admin_feedback TEXT
   - created_at, updated_at TIMESTAMPTZ with defaults, published_at TIMESTAMPTZ nullable
   - CHECK constraint: rejection_reason_required (status != 'rejected' OR rejection_reason IS NOT NULL)
   - Indexes on status and thread_id

2. Create `src/editorial_ai/services/content_service.py` following existing service patterns (celeb_service.py, product_service.py):
   - `save_pending_content(thread_id, layout_json, title, keyword, review_summary=None) -> dict` -- upsert on thread_id (idempotent for node re-execution). Use `get_supabase_client()` from supabase_client.py.
   - `update_content_status(content_id, status, rejection_reason=None, admin_feedback=None) -> dict` -- update status, set published_at=now() if status is 'published', set updated_at=now().
   - `get_content_by_id(content_id) -> dict | None`
   - `get_content_by_thread_id(thread_id) -> dict | None`
   - `list_contents_by_status(status, limit=50, offset=0) -> list[dict]` -- order by created_at desc
   - All functions are async. Follow the `await client.table("editorial_contents")...execute()` pattern.

3. Create `tests/test_content_service.py` with mocked Supabase client (use MagicMock/AsyncMock pattern from existing tests like test_services.py):
   - Test save_pending_content creates correct insert payload
   - Test update_content_status with approval sets correct fields
   - Test update_content_status with rejection includes rejection_reason
   - Test list_contents_by_status passes correct filter
   - Test get_content_by_thread_id passes correct eq filter
  </action>
  <verify>cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run pytest tests/test_content_service.py -v</verify>
  <done>content_service.py has 5 async functions for editorial_contents CRUD, SQL migration exists, all unit tests pass</done>
</task>

<task type="auto">
  <name>Task 2: admin_gate node + publish node</name>
  <files>
    src/editorial_ai/nodes/admin_gate.py
    src/editorial_ai/nodes/publish.py
  </files>
  <action>
1. Create `src/editorial_ai/nodes/admin_gate.py`:
   - Import `interrupt` from `langgraph.types` (NOT `NodeInterrupt` -- that's deprecated)
   - The node is async: `async def admin_gate(state: EditorialPipelineState) -> dict`
   - CRITICAL ordering per RESEARCH.md:
     a. First, save content to Supabase using `save_pending_content()` (uses upsert on thread_id so it's idempotent on re-execution). Extract title from `state["current_draft"]["metadata"]["title"]`, keyword from `state["curation_input"]["seed_keyword"]`, layout_json from `state["current_draft"]`, review_summary from `state["review_result"].get("summary")`.
     b. Set `pipeline_status: "awaiting_approval"` in returned state update.
     c. Call `interrupt(snapshot)` where snapshot includes content_id (from upsert response), title, keyword, review_summary -- this is what the admin sees.
     d. After resume: `admin_response = interrupt(snapshot)` returns the Command(resume=...) value.
     e. Branch on `admin_response["decision"]`:
        - "approved": return `{"admin_decision": "approved"}`
        - "revision_requested": return `{"admin_decision": "revision_requested", "admin_feedback": admin_response.get("feedback", "")}`
        - "rejected": return `{"admin_decision": "rejected", "admin_feedback": admin_response.get("reason", ""), "pipeline_status": "failed"}`. Also call `update_content_status(content_id, "rejected", rejection_reason=admin_response["reason"])`.
   - Add logging at each decision branch.
   - NOTE: Since save_pending_content uses upsert on thread_id, the re-execution on resume is safe (idempotent).

2. Create `src/editorial_ai/nodes/publish.py`:
   - Async function: `async def publish_node(state: EditorialPipelineState) -> dict`
   - Get content by thread_id from Supabase (need thread_id from config -- use `state` or extract from interrupt context). Actually, get_content_by_thread_id is simpler since admin_gate already saved it.
   - NOTE: The node does NOT have access to thread_id from config. Instead, look up content by thread_id. But the node doesn't know the thread_id either. Solution: store content_id in state. Add it in admin_gate's return when approved. OR: Use the thread_id that was used when saving. Simplest: admin_gate stores content_id in state update on approval.
   - Revised approach: admin_gate on approval returns `{"admin_decision": "approved", "content_id": content_id}` where content_id came from the upsert. But content_id is not in EditorialPipelineState. Instead, look up by thread_id. But publish_node doesn't know thread_id. Simplest solution: store `current_draft_id` in state (it already exists in state as `current_draft_id: str | None`). admin_gate sets `current_draft_id` to the Supabase content UUID.
   - Call `update_content_status(current_draft_id, "approved")` then `update_content_status(current_draft_id, "published", published_at=now())`. Or combine: just update to "published" directly since approval is implicit.
   - Return `{"pipeline_status": "published"}`
   - Add logging.
  </action>
  <verify>cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run python -c "from editorial_ai.nodes.admin_gate import admin_gate; from editorial_ai.nodes.publish import publish_node; print('imports ok')"</verify>
  <done>admin_gate node uses interrupt() pattern with idempotent content save, publish node updates content to published status, both import cleanly</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_content_service.py -v` passes
- `uv run ruff check src/editorial_ai/services/content_service.py src/editorial_ai/nodes/admin_gate.py src/editorial_ai/nodes/publish.py` clean
- `from editorial_ai.nodes.admin_gate import admin_gate` succeeds
- `from editorial_ai.nodes.publish import publish_node` succeeds
- SQL migration file exists at supabase/migrations/001_editorial_contents.sql
</verification>

<success_criteria>
- content_service.py provides full CRUD for editorial_contents table (save, update status, get by id, get by thread_id, list by status)
- admin_gate.py implements interrupt() at correct position (after idempotent save, before side effects)
- publish_node updates content status to published and returns pipeline_status="published"
- All unit tests pass
- Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/07-admin-backend-hitl/07-01-SUMMARY.md`
</output>
