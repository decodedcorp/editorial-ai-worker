---
phase: 03-curation-agent
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/editorial_ai/nodes/curation.py
  - src/editorial_ai/graph.py
  - tests/test_curation_node.py
autonomous: true

must_haves:
  truths:
    - "Curation node reads seed keyword from state['curation_input'] and writes structured topics to state['curated_topics']"
    - "Pipeline status transitions from 'curating' to 'sourcing' after successful curation"
    - "API failure after all retries records error in state['error_log'] and sets pipeline_status='failed'"
    - "Graph uses real curation node instead of stub when imported from nodes/curation.py"
    - "Node function is async (uses await for CurationService)"
  artifacts:
    - path: "src/editorial_ai/nodes/curation.py"
      provides: "Async curation_node function for LangGraph"
      exports: ["curation_node"]
    - path: "src/editorial_ai/graph.py"
      provides: "Updated build_graph with real curation node as default"
    - path: "tests/test_curation_node.py"
      provides: "Node-level tests verifying state reads/writes and error handling"
  key_links:
    - from: "src/editorial_ai/nodes/curation.py"
      to: "src/editorial_ai/services/curation_service.py"
      via: "CurationService.curate_seed() call"
      pattern: "CurationService.*curate_seed"
    - from: "src/editorial_ai/nodes/curation.py"
      to: "src/editorial_ai/state.py"
      via: "Reads curation_input, writes curated_topics + pipeline_status"
      pattern: "state\\[.curation_input.\\]"
    - from: "src/editorial_ai/graph.py"
      to: "src/editorial_ai/nodes/curation.py"
      via: "Import curation_node as default for 'curation' node"
      pattern: "from editorial_ai\\.nodes\\.curation import curation_node"
---

<objective>
Wire the CurationService into the LangGraph pipeline: create an async curation node that reads seed keyword from state, calls CurationService, writes structured results to state, and handles errors gracefully. Update the graph to use the real curation node.

Purpose: Connect the service layer (Plan 03-01) to the pipeline so running the graph with a seed keyword triggers actual trend curation via Gemini grounding.

Output: Working curation node integrated into the graph, with tests proving state transitions and error handling.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-curation-agent/03-CONTEXT.md
@.planning/phases/03-curation-agent/03-RESEARCH.md
@.planning/phases/03-curation-agent/03-01-SUMMARY.md
@src/editorial_ai/state.py
@src/editorial_ai/graph.py
@src/editorial_ai/nodes/stubs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Curation node and graph wiring</name>
  <files>
    src/editorial_ai/nodes/curation.py
    src/editorial_ai/graph.py
  </files>
  <action>
Create `src/editorial_ai/nodes/curation.py` with an async node function:

```python
async def curation_node(state: EditorialPipelineState) -> dict:
```

**Node logic:**
1. Read `state["curation_input"]` — expected to contain `{"keyword": "..."}`. If missing or no keyword, return error state immediately:
   ```python
   return {
       "pipeline_status": "failed",
       "error_log": ["Curation failed: no seed keyword provided in curation_input"],
   }
   ```

2. Create CurationService: `CurationService(get_genai_client())`

3. Call `await service.curate_seed(keyword)`

4. On success, return:
   ```python
   {
       "pipeline_status": "sourcing",
       "curated_topics": [t.model_dump() for t in result.topics],
   }
   ```

5. On exception (after all retries exhausted), catch the exception and return:
   ```python
   {
       "pipeline_status": "failed",
       "error_log": [f"Curation failed: {type(e).__name__}: {str(e)}"],
       "curated_topics": [],
   }
   ```

**Keep the node thin** — all business logic is in CurationService. The node only handles state I/O and error wrapping.

**Update `src/editorial_ai/graph.py`:**
- Import `curation_node` from `editorial_ai.nodes.curation`
- Change the default nodes dict: replace `stub_curation` with `curation_node` for the "curation" key
- Keep `stub_curation` import for backward compatibility (other tests may use it via node_overrides)
- The `node_overrides` mechanism still allows overriding curation for tests

**Important:** The curation_node is async. LangGraph StateGraph handles async nodes natively — no special configuration needed. The graph caller must use `await graph.ainvoke()` instead of `graph.invoke()`.
  </action>
  <verify>
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run python -c "from editorial_ai.nodes.curation import curation_node; from editorial_ai.graph import build_graph; print('OK')"`

Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run mypy src/editorial_ai/nodes/curation.py src/editorial_ai/graph.py --ignore-missing-imports`
  </verify>
  <done>
curation_node importable and wired into build_graph as default. Graph still compiles. mypy passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Curation node tests and existing test compatibility</name>
  <files>
    tests/test_curation_node.py
    tests/test_graph.py
  </files>
  <action>
Create `tests/test_curation_node.py` with async tests:

**Test fixtures:**
- `mock_curation_service`: Patch `editorial_ai.nodes.curation.CurationService` and `editorial_ai.nodes.curation.get_genai_client` so no real API calls are made
- `sample_curation_result`: CurationResult with 3 CuratedTopics

**Test cases:**

1. `test_curation_node_success` — Mock CurationService.curate_seed to return sample result. Call curation_node with state containing `curation_input={"keyword": "Y2K"}`. Assert:
   - Returns `pipeline_status="sourcing"`
   - Returns `curated_topics` as list of dicts (model_dump output)
   - Length matches sample result topics

2. `test_curation_node_missing_keyword` — Call with `curation_input={}` or `curation_input` missing. Assert:
   - Returns `pipeline_status="failed"`
   - Returns `error_log` with descriptive message
   - Does NOT call CurationService

3. `test_curation_node_api_failure` — Mock CurationService.curate_seed to raise Exception. Assert:
   - Returns `pipeline_status="failed"`
   - Returns `error_log` with exception info
   - Returns `curated_topics=[]`

4. `test_curation_node_empty_results` — Mock CurationService.curate_seed to return CurationResult with empty topics (all filtered). Assert:
   - Returns `pipeline_status="sourcing"` (not failed — empty is valid)
   - Returns `curated_topics=[]`

5. `test_graph_compilation_with_real_curation_node` — Call `build_graph()` without overrides. Assert it compiles (returns CompiledStateGraph). This verifies the async node doesn't break graph compilation.

**Fix existing tests if needed:**
- Check `tests/test_graph.py` — existing tests likely use `graph.invoke()` (sync). Since curation node is now async, existing tests that invoke the full graph may need `node_overrides={"curation": stub_curation}` to keep using sync stubs, OR switch to `await graph.ainvoke()`.
- Read `tests/test_graph.py` first. If tests use `build_graph()` without overrides and call `invoke()`, update them to either:
  (a) Pass `node_overrides={"curation": stub_curation}` to keep them sync, OR
  (b) Convert to async tests using `ainvoke()`
- Prefer option (a) — graph topology tests should remain fast and not depend on curation implementation.
  </action>
  <verify>
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run pytest tests/test_curation_node.py -v` — All new tests pass

Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run pytest tests/test_graph.py -v` — Existing graph tests still pass (no regression)

Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run pytest tests/ -v` — Full test suite passes
  </verify>
  <done>
5+ curation node tests pass. All existing graph tests pass without regression. Full test suite green. The graph compiles with the real async curation node as default.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from editorial_ai.nodes.curation import curation_node; print('Node OK')"` — Node importable
2. `uv run python -c "from editorial_ai.graph import build_graph; g = build_graph(); print('Graph OK')"` — Graph compiles with real curation node
3. `uv run pytest tests/test_curation_node.py -v` — All node tests pass
4. `uv run pytest tests/test_graph.py -v` — Existing graph tests pass (no regression)
5. `uv run pytest tests/ -v` — Full suite green
6. `uv run ruff check src/editorial_ai/nodes/curation.py` — No lint errors
</verification>

<success_criteria>
- Curation node reads curation_input from state, calls CurationService, writes curated_topics to state
- Pipeline status transitions: curating → sourcing (success) or curating → failed (error)
- Error handling: missing keyword returns error state; API failure after retries returns error state with error_log
- Graph compiles with real curation node as default
- All existing tests pass without regression
- Node tests verify state reads/writes without real API calls
</success_criteria>

<output>
After completion, create `.planning/phases/03-curation-agent/03-02-SUMMARY.md`
</output>
