---
phase: 11-magazine-renderer-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/editorial_ai/models/design_spec.py
  - src/editorial_ai/models/layout.py
  - src/editorial_ai/prompts/design_spec.py
  - src/editorial_ai/services/design_spec_service.py
  - src/editorial_ai/nodes/design_spec.py
  - src/editorial_ai/nodes/editorial.py
  - src/editorial_ai/state.py
  - src/editorial_ai/graph.py
autonomous: true

must_haves:
  truths:
    - "DesignSpec Pydantic model captures font pairing, color palette, layout density, mood, and hero aspect ratio"
    - "design_spec node generates a DesignSpec from curated keyword + category via Gemini"
    - "design_spec node is inserted into the graph after curation and before source"
    - "DesignSpec travels in pipeline state as design_spec field (dict)"
    - "design_spec node failure does not crash the pipeline — falls back to default spec"
    - "editorial_node injects state['design_spec'] into MagazineLayout before returning current_draft"
  artifacts:
    - path: "src/editorial_ai/models/design_spec.py"
      provides: "DesignSpec, FontPairing, ColorPalette Pydantic models"
      contains: "class DesignSpec"
    - path: "src/editorial_ai/prompts/design_spec.py"
      provides: "Prompt builder for design spec generation"
      contains: "def build_design_spec_prompt"
    - path: "src/editorial_ai/services/design_spec_service.py"
      provides: "DesignSpecService that calls Gemini to generate specs"
      contains: "class DesignSpecService"
    - path: "src/editorial_ai/nodes/design_spec.py"
      provides: "design_spec_node async function for LangGraph"
      contains: "async def design_spec_node"
    - path: "src/editorial_ai/nodes/editorial.py"
      provides: "Updated editorial node that injects design_spec into layout"
      contains: "design_spec"
    - path: "src/editorial_ai/state.py"
      provides: "Updated state with design_spec field"
      contains: "design_spec"
    - path: "src/editorial_ai/graph.py"
      provides: "Graph with design_spec node between curation and source"
      contains: "design_spec"
  key_links:
    - from: "src/editorial_ai/nodes/design_spec.py"
      to: "src/editorial_ai/services/design_spec_service.py"
      via: "Node calls service to generate design spec"
    - from: "src/editorial_ai/services/design_spec_service.py"
      to: "src/editorial_ai/models/design_spec.py"
      via: "Service returns DesignSpec model"
    - from: "src/editorial_ai/graph.py"
      to: "src/editorial_ai/nodes/design_spec.py"
      via: "Graph registers design_spec_node"
---

<objective>
Create the AI-driven design_spec pipeline node that generates dynamic theme specifications (fonts, colors, layout, mood) from the curated keyword. Wire it into the LangGraph pipeline between curation and source.

Purpose: Each keyword gets a unique visual identity generated by Gemini, enabling the magazine renderer to apply per-content theming rather than static styles.
Output: `design_spec` node in the pipeline that produces a `DesignSpec` dict in state, with fallback to a sensible default on failure.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-magazine-renderer-enhancement/11-CONTEXT.md
@.planning/phases/11-magazine-renderer-enhancement/11-RESEARCH.md
@src/editorial_ai/state.py
@src/editorial_ai/graph.py
@src/editorial_ai/models/layout.py
@src/editorial_ai/models/curation.py
@src/editorial_ai/services/curation_service.py
@src/editorial_ai/nodes/curation.py
@src/editorial_ai/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DesignSpec Pydantic model + prompt</name>
  <files>
    src/editorial_ai/models/design_spec.py
    src/editorial_ai/models/__init__.py
    src/editorial_ai/prompts/design_spec.py
    src/editorial_ai/prompts/__init__.py
  </files>
  <action>
Create `src/editorial_ai/models/design_spec.py` with these Pydantic v2 models:

1. **FontPairing(BaseModel):**
   - `headline_font: str` — Google Fonts name for headlines (e.g., "Playfair Display")
   - `body_font: str` — Google Fonts name for body text (e.g., "Noto Sans KR")
   - `accent_font: str | None = None` — optional accent font for pull quotes, etc.

2. **ColorPalette(BaseModel):**
   - `primary: str` — hex color (e.g., "#1a1a2e")
   - `secondary: str` — hex color
   - `accent: str` — hex color
   - `background: str = "#ffffff"`
   - `text: str = "#1a1a1a"`
   - `muted: str = "#6b7280"`

3. **DesignSpec(BaseModel):**
   - `font_pairing: FontPairing`
   - `color_palette: ColorPalette`
   - `layout_density: Literal["compact", "normal", "spacious"]` — controls spacing/padding
   - `mood: str` — 1-2 word mood descriptor (e.g., "elegant minimal", "bold urban")
   - `hero_aspect_ratio: str = "16/9"` — CSS aspect-ratio value
   - `drop_cap: bool = True` — whether to use drop caps on body text

Include a module-level function `default_design_spec() -> DesignSpec` that returns:
- FontPairing: headline="Georgia", body="Pretendard", accent=None
- ColorPalette: primary="#1a1a2e", secondary="#16213e", accent="#e94560", background="#ffffff", text="#1a1a1a", muted="#6b7280"
- layout_density="normal", mood="elegant editorial", hero_aspect_ratio="16/9", drop_cap=True

Create `src/editorial_ai/prompts/design_spec.py`:

Define `build_design_spec_prompt(keyword: str, category: str | None = None) -> str` that returns a system prompt instructing Gemini to:
- Generate a design specification for a fashion editorial magazine about the given keyword
- Output valid JSON matching the DesignSpec schema (include the schema in the prompt)
- Choose fonts ONLY from this curated Google Fonts list:
  - Serif: Playfair Display, Lora, Noto Serif KR, DM Serif Display, Cormorant Garamond
  - Sans-serif: Gothic A1, Noto Sans KR, Inter, Montserrat, Raleway
- Consider the mood/tone that fits the keyword
- Choose colors that evoke the right editorial atmosphere
- Pick an appropriate hero aspect ratio (16/9, 4/3, 3/2, 21/9)

Update `__init__.py` files to export new models/functions.
  </action>
  <verify>
`python -c "from editorial_ai.models.design_spec import DesignSpec, default_design_spec; spec = default_design_spec(); print(spec.model_dump_json(indent=2))"` succeeds and prints valid JSON.
`python -c "from editorial_ai.prompts.design_spec import build_design_spec_prompt; print(build_design_spec_prompt('Y2K fashion')[:100])"` succeeds.
  </verify>
  <done>DesignSpec model with font pairing, color palette, layout density, mood, and hero aspect ratio. Prompt builder generates Gemini instructions for dynamic spec generation.</done>
</task>

<task type="auto">
  <name>Task 2: DesignSpec service + node + graph wiring + layout model</name>
  <files>
    src/editorial_ai/services/design_spec_service.py
    src/editorial_ai/nodes/design_spec.py
    src/editorial_ai/nodes/editorial.py
    src/editorial_ai/state.py
    src/editorial_ai/graph.py
    src/editorial_ai/models/layout.py
    src/editorial_ai/nodes/stubs.py
  </files>
  <action>
**Create `src/editorial_ai/services/design_spec_service.py`:**

Class `DesignSpecService`:
- `__init__(self, client: genai.Client | None = None, model_name: str | None = None)` — uses `get_genai_client()` from curation_service pattern and `settings.default_model`
- `async def generate_spec(self, keyword: str, category: str | None = None) -> DesignSpec`:
  - Build prompt using `build_design_spec_prompt(keyword, category)`
  - Call `self.client.aio.models.generate_content(model=self.model_name, contents=prompt, config=types.GenerateContentConfig(response_mime_type="application/json", response_schema=DesignSpec))`
  - Parse response text as JSON, validate with `DesignSpec.model_validate()`
  - Record token usage via `record_token_usage` (same pattern as curation_service)
  - On any failure, log warning and return `default_design_spec()`

**Create `src/editorial_ai/nodes/design_spec.py`:**

`async def design_spec_node(state: EditorialPipelineState) -> dict`:
- Extract keyword from `state["curated_topics"][0]["main_keyword"]` if available, else from `state["curation_input"]["seed_keyword"]`
- Extract category from `state["curation_input"].get("category")`
- Call `DesignSpecService().generate_spec(keyword, category)`
- Return `{"design_spec": spec.model_dump()}`
- On any exception: log warning, return `{"design_spec": default_design_spec().model_dump()}`

**Update `src/editorial_ai/state.py`:**

Add field to `EditorialPipelineState`:
- `design_spec: dict | None` — between `curated_topics` and `enriched_contexts` comment sections

**Update `src/editorial_ai/graph.py`:**

1. Import `design_spec_node` from `editorial_ai.nodes.design_spec`
2. Add `"design_spec": design_spec_node` to the `nodes` dict
3. Change edge from `curation -> source` to `curation -> design_spec -> source`:
   - Replace `builder.add_edge("curation", "source")` with:
   - `builder.add_edge("curation", "design_spec")`
   - `builder.add_edge("design_spec", "source")`

**Update `src/editorial_ai/models/layout.py`:**

Add optional `design_spec` field to `MagazineLayout` so the spec travels with the layout JSON:
1. Import `DesignSpec` from `editorial_ai.models.design_spec`
2. Add field: `design_spec: DesignSpec | None = None` to `MagazineLayout` class (after `metadata`)

This allows the design spec to be stored alongside the layout and delivered to the frontend via the existing API.

**Update `src/editorial_ai/nodes/editorial.py`:**

After `layout = await service.create_editorial(...)` and before `return`, inject the design spec from state into the layout so it travels with `current_draft` to the DB:

```python
# Inject design_spec into layout so it persists in layout_json
design_spec = state.get("design_spec")
if design_spec:
    layout.design_spec = DesignSpec.model_validate(design_spec)
```

Add the necessary import at the top:
```python
from editorial_ai.models.design_spec import DesignSpec
```

This closes the wiring gap: `design_spec_node -> state["design_spec"] -> editorial_node injects into layout -> admin_gate saves layout_json (with design_spec) to DB -> frontend reads layout_json.design_spec`.

**Update `src/editorial_ai/nodes/stubs.py`:**

Add a `stub_design_spec` function that returns a default DesignSpec dict:
```python
async def stub_design_spec(state):
    from editorial_ai.models.design_spec import default_design_spec
    return {"design_spec": default_design_spec().model_dump()}
```
  </action>
  <verify>
1. `python -c "from editorial_ai.graph import build_graph; g = build_graph(); print('Graph compiled OK')"` succeeds
2. `python -c "from editorial_ai.state import EditorialPipelineState; print('design_spec' in EditorialPipelineState.__annotations__)"` prints True
3. `python -c "from editorial_ai.nodes.stubs import stub_design_spec; print('OK')"` succeeds
  </verify>
  <done>DesignSpec service generates specs via Gemini with fallback to default. Node wired into graph between curation and source. State carries design_spec dict.</done>
</task>

</tasks>

<verification>
1. `python -c "from editorial_ai.graph import build_graph; g = build_graph(); print(g.get_graph().nodes)"` — shows design_spec node in graph
2. `python -c "from editorial_ai.models.design_spec import DesignSpec, default_design_spec; s = default_design_spec(); DesignSpec.model_validate(s.model_dump()); print('Round-trip OK')"` — model round-trips
3. Graph topology: curation -> design_spec -> source -> editorial -> enrich -> review -> admin_gate -> publish
4. Stub test: `python -c "import asyncio; from editorial_ai.nodes.stubs import stub_design_spec; print(asyncio.run(stub_design_spec({})))"` returns dict with design_spec key
</verification>

<success_criteria>
- DesignSpec Pydantic model captures all theme dimensions (fonts, colors, density, mood, hero ratio)
- design_spec node in graph between curation and source
- Gemini generates dynamic design specs from keyword
- Failure falls back to default spec (never crashes pipeline)
- State carries design_spec dict for downstream consumption
</success_criteria>

<output>
After completion, create `.planning/phases/11-magazine-renderer-enhancement/11-01-SUMMARY.md`
</output>
