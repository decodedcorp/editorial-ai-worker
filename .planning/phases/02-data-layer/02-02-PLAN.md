---
phase: 02-data-layer
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/editorial_ai/checkpointer.py
  - src/editorial_ai/graph.py
  - tests/test_checkpointer.py
  - tests/test_graph.py
autonomous: true

must_haves:
  truths:
    - "build_graph() accepts an optional checkpointer parameter and compiles successfully with it"
    - "Graph compiled with MemorySaver persists state across invocations with the same thread_id"
    - "Graph state after checkpointing contains only lean data (IDs, status, small dicts) — no full payloads"
    - "Checkpointer factory function exists and can create AsyncPostgresSaver from DATABASE_URL"
    - "Module-level graph (no checkpointer) still works for simple testing"
  artifacts:
    - path: "src/editorial_ai/checkpointer.py"
      provides: "AsyncPostgresSaver factory for Supabase Postgres pooler"
      exports: ["create_checkpointer"]
    - path: "src/editorial_ai/graph.py"
      provides: "build_graph with optional checkpointer parameter"
      contains: "checkpointer"
    - path: "tests/test_checkpointer.py"
      provides: "Checkpointer integration tests using MemorySaver"
  key_links:
    - from: "src/editorial_ai/checkpointer.py"
      to: "src/editorial_ai/config.py"
      via: "settings.database_url"
      pattern: "settings\\.database_url"
    - from: "src/editorial_ai/graph.py"
      to: "langgraph.checkpoint.base"
      via: "BaseCheckpointSaver type hint"
      pattern: "BaseCheckpointSaver"
    - from: "tests/test_checkpointer.py"
      to: "src/editorial_ai/graph.py"
      via: "build_graph(checkpointer=MemorySaver())"
      pattern: "build_graph.*checkpointer"
---

<objective>
AsyncPostgresSaver 체크포인터 팩토리를 만들고, build_graph()에 checkpointer 파라미터를 추가하여, 그래프 상태가 영속화될 수 있는 인프라를 구축한다.

Purpose: 체크포인터가 있으면 그래프 실행을 중단/재개할 수 있다. Phase 7의 Admin HITL interrupt 패턴의 기반이 되며, 장애 복구 시에도 마지막 체크포인트에서 재개할 수 있다. Lean state 원칙을 검증하여 체크포인터에 불필요한 대량 데이터가 저장되지 않도록 보장한다.

Output: `src/editorial_ai/checkpointer.py` 체크포인터 팩토리, `graph.py`에 checkpointer 파라미터 추가, MemorySaver 기반 테스트가 통과한다.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer/02-CONTEXT.md
@.planning/phases/02-data-layer/02-RESEARCH.md
@.planning/phases/02-data-layer/02-01-SUMMARY.md
@src/editorial_ai/graph.py
@src/editorial_ai/config.py
@src/editorial_ai/state.py
@tests/test_graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkpointer factory and extend build_graph with checkpointer parameter</name>
  <files>
    src/editorial_ai/checkpointer.py
    src/editorial_ai/graph.py
  </files>
  <action>
1. Create `src/editorial_ai/checkpointer.py`:
   ```python
   """AsyncPostgresSaver factory for graph state persistence.

   Uses Supabase's Postgres session pooler (port 5432).
   The factory returns an async context manager — caller manages lifecycle.
   """
   from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
   from editorial_ai.config import settings

   def create_checkpointer() -> AsyncPostgresSaver:
       """Create an AsyncPostgresSaver from DATABASE_URL.

       Returns an async context manager. Usage:
           async with create_checkpointer() as checkpointer:
               await checkpointer.setup()
               graph = build_graph(checkpointer=checkpointer)
               ...

       from_conn_string() sets autocommit=True, prepare_threshold=0
       automatically — compatible with Supabase pooler.
       """
       if not settings.database_url:
           raise ValueError(
               "DATABASE_URL is required for checkpointer. "
               "Set it to your Supabase session pooler connection string (port 5432)."
           )
       return AsyncPostgresSaver.from_conn_string(settings.database_url)
   ```

   Key design decisions:
   - Returns the result of `from_conn_string()` which is an async context manager.
   - Caller uses `async with create_checkpointer() as saver:` to manage lifecycle.
   - Raises ValueError early if DATABASE_URL is not configured.
   - Does NOT call `setup()` — that's the caller's responsibility (idempotent, call once).

2. Modify `src/editorial_ai/graph.py` `build_graph()` function:
   - Add `checkpointer` parameter: `checkpointer: BaseCheckpointSaver | None = None`
   - Import `BaseCheckpointSaver` from `langgraph.checkpoint.base`
   - Pass to `builder.compile(checkpointer=checkpointer)`
   - The module-level `graph = build_graph()` remains unchanged (no checkpointer = in-memory only, for quick testing).

   Updated signature:
   ```python
   from langgraph.checkpoint.base import BaseCheckpointSaver

   def build_graph(
       *,
       node_overrides: dict[str, Callable[..., Any]] | None = None,
       checkpointer: BaseCheckpointSaver | None = None,
   ) -> CompiledStateGraph:
       # ... existing builder setup unchanged ...
       return builder.compile(checkpointer=checkpointer)
   ```

3. Verify imports: `uv run python -c "from editorial_ai.checkpointer import create_checkpointer; print('OK')"`
4. Verify graph still works: `uv run pytest tests/test_graph.py -v` (existing tests must pass).
5. Run `uv run ruff check src/editorial_ai/` and `uv run mypy src/editorial_ai/`.
  </action>
  <verify>
    - `uv run python -c "from editorial_ai.checkpointer import create_checkpointer; print('OK')"` — import succeeds
    - `uv run pytest tests/test_graph.py -v` — existing graph tests still pass (backward compatible)
    - `uv run ruff check src/editorial_ai/` — clean
  </verify>
  <done>
    - checkpointer.py exists with create_checkpointer() factory
    - build_graph() accepts optional checkpointer parameter
    - Module-level graph = build_graph() unchanged (no checkpointer, backward compatible)
    - Existing tests unbroken
  </done>
</task>

<task type="auto">
  <name>Task 2: MemorySaver checkpointer tests and lean state validation</name>
  <files>
    tests/test_checkpointer.py
    tests/test_graph.py
  </files>
  <action>
1. Create `tests/test_checkpointer.py` with MemorySaver-based tests:

   **Test 1: Graph compiles with checkpointer**
   ```python
   def test_build_graph_with_checkpointer():
       from langgraph.checkpoint.memory import MemorySaver
       checkpointer = MemorySaver()
       graph = build_graph(checkpointer=checkpointer)
       assert graph is not None
   ```

   **Test 2: State persists across invocations with same thread_id**
   ```python
   async def test_state_persists_with_checkpointer():
       """Verify that graph state is saved and retrievable via thread_id."""
       from langgraph.checkpoint.memory import MemorySaver
       checkpointer = MemorySaver()
       graph = build_graph(checkpointer=checkpointer)

       config = {"configurable": {"thread_id": "test-persist-001"}}

       # Invoke graph with minimal input (stub nodes)
       result = await graph.ainvoke(
           {"curation_input": {"keyword": "spring fashion"}},
           config=config,
       )

       # Retrieve saved state
       saved = await graph.aget_state(config)
       assert saved is not None
       assert saved.values.get("pipeline_status") is not None
   ```

   **Test 3: State recoverable with same thread_id (resume scenario)**
   ```python
   async def test_state_recoverable_on_resume():
       """Simulate process restart: build new graph, same thread_id, state restored."""
       from langgraph.checkpoint.memory import MemorySaver
       checkpointer = MemorySaver()

       # First invocation
       graph1 = build_graph(checkpointer=checkpointer)
       config = {"configurable": {"thread_id": "test-resume-001"}}
       await graph1.ainvoke(
           {"curation_input": {"keyword": "summer trends"}},
           config=config,
       )

       # "Restart": build new graph with SAME checkpointer
       graph2 = build_graph(checkpointer=checkpointer)
       saved = await graph2.aget_state(config)
       assert saved is not None
       assert saved.values.get("curation_input") == {"keyword": "summer trends"}
   ```

   **Test 4: Lean state validation — no fat payloads**
   ```python
   async def test_lean_state_no_fat_payloads():
       """Verify checkpointed state contains only lean data (IDs, status, small dicts).

       The lean state principle: IDs and references only, not full payloads.
       This test ensures the state schema enforces this by checking that
       all values in the checkpointed state are reasonably small.
       """
       from langgraph.checkpoint.memory import MemorySaver
       import json

       checkpointer = MemorySaver()
       graph = build_graph(checkpointer=checkpointer)
       config = {"configurable": {"thread_id": "test-lean-001"}}

       await graph.ainvoke(
           {"curation_input": {"keyword": "test"}},
           config=config,
       )

       saved = await graph.aget_state(config)
       state = saved.values

       # Serialize state to JSON and check total size
       state_json = json.dumps(state, default=str)
       # Lean state should be well under 10KB even with all fields populated
       assert len(state_json) < 10_000, (
           f"State too large ({len(state_json)} bytes). "
           "Check for fat payloads violating lean state principle."
       )
   ```

   **Test 5: Different thread_ids are isolated**
   ```python
   async def test_thread_isolation():
       """Different thread_ids have independent state."""
       from langgraph.checkpoint.memory import MemorySaver
       checkpointer = MemorySaver()
       graph = build_graph(checkpointer=checkpointer)

       config_a = {"configurable": {"thread_id": "thread-a"}}
       config_b = {"configurable": {"thread_id": "thread-b"}}

       await graph.ainvoke({"curation_input": {"keyword": "alpha"}}, config=config_a)
       await graph.ainvoke({"curation_input": {"keyword": "beta"}}, config=config_b)

       state_a = await graph.aget_state(config_a)
       state_b = await graph.aget_state(config_b)

       assert state_a.values["curation_input"]["keyword"] == "alpha"
       assert state_b.values["curation_input"]["keyword"] == "beta"
   ```

2. Optionally add one test to `tests/test_graph.py` to confirm backward compatibility:
   ```python
   def test_build_graph_without_checkpointer_still_works():
       """Ensure build_graph() without checkpointer param is backward compatible."""
       graph = build_graph()
       assert graph is not None
   ```
   (Only add if this test doesn't already exist.)

3. Run `uv run pytest tests/ -v` to verify ALL tests pass.
4. Run `uv run ruff check src/ tests/` and `uv run mypy src/editorial_ai/`.
  </action>
  <verify>
    - `uv run pytest tests/test_checkpointer.py -v` — all 5 tests pass
    - `uv run pytest tests/ -v` — all tests pass (existing + new)
    - `uv run ruff check src/ tests/` — clean
  </verify>
  <done>
    - 5 checkpointer tests pass using MemorySaver (no external DB dependency)
    - State persistence, resume, lean state validation, and thread isolation all verified
    - Existing graph tests still pass (backward compatible)
    - All lint checks pass
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -v` — all tests pass (services + checkpointer + graph)
2. `uv run ruff check src/ tests/` — clean
3. `uv run mypy src/editorial_ai/` — clean (or pre-existing issues only)
4. `uv run python -c "from editorial_ai.checkpointer import create_checkpointer; from editorial_ai.graph import build_graph; print('all imports OK')"` — resolves
5. `build_graph(checkpointer=None)` produces same graph as `build_graph()` — backward compatible
</verification>

<success_criteria>
- checkpointer.py factory creates AsyncPostgresSaver from DATABASE_URL
- build_graph() accepts optional checkpointer, passes it to compile()
- Module-level graph remains checkpointer-free (backward compatible)
- MemorySaver tests verify: persistence, resume, lean state (<10KB), thread isolation
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer/02-02-SUMMARY.md`
</output>
