---
phase: 04-editorial-agent-generation-layout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/editorial_ai/models/editorial.py
  - src/editorial_ai/models/layout.py
  - src/editorial_ai/models/__init__.py
  - tests/test_editorial_models.py
autonomous: true

must_haves:
  truths:
    - "Magazine Layout JSON schema validates a well-formed editorial layout with blocks"
    - "Schema includes schema_version field for versioning"
    - "All 10 block types (hero, headline, body_text, image_gallery, pull_quote, product_showcase, celeb_feature, divider, hashtag_bar, credits) are defined"
    - "Editorial content model captures generated text, title, and content elements"
    - "Default template layout can be created programmatically"
  artifacts:
    - path: "src/editorial_ai/models/layout.py"
      provides: "Magazine Layout JSON Pydantic schema with block types"
      contains: "MagazineLayout"
    - path: "src/editorial_ai/models/editorial.py"
      provides: "Editorial content generation models"
      contains: "EditorialContent"
    - path: "tests/test_editorial_models.py"
      provides: "Model validation tests"
      exports: []
  key_links:
    - from: "src/editorial_ai/models/layout.py"
      to: "pydantic BaseModel"
      via: "Pydantic v2 model classes"
      pattern: "class.*BaseModel"
    - from: "src/editorial_ai/models/editorial.py"
      to: "src/editorial_ai/models/layout.py"
      via: "imports block types for content-layout mapping"
      pattern: "from editorial_ai.models.layout import"
---

<objective>
Define the Magazine Layout JSON Pydantic schema and editorial content models that serve as the contract between this AI pipeline and the decoded-editorial frontend renderer.

Purpose: The layout schema is the core data contract for Phase 4. All subsequent plans (content generation, Nano Banana, vision parsing) produce output conforming to this schema. It also serves as the renderer spec for the frontend team.
Output: Pydantic models for 10 block types, MagazineLayout container, EditorialContent model, default template factory, and validation tests.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing model patterns
@src/editorial_ai/models/curation.py
@src/editorial_ai/models/__init__.py

# Research findings for schema design
@.planning/phases/04-editorial-agent-generation-layout/04-RESEARCH.md
@.planning/phases/04-editorial-agent-generation-layout/04-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Magazine Layout JSON Pydantic schema</name>
  <files>src/editorial_ai/models/layout.py, src/editorial_ai/models/__init__.py</files>
  <action>
Create `src/editorial_ai/models/layout.py` with Pydantic v2 models for the block-based Magazine Layout JSON schema.

**Block type models (each extends BaseModel with ConfigDict(from_attributes=True)):**

1. `HeroBlock` — type="hero", image_url (str), overlay_title (str | None), overlay_subtitle (str | None)
2. `HeadlineBlock` — type="headline", text (str), level (int, default=1, ge=1, le=3)
3. `BodyTextBlock` — type="body_text", paragraphs (list[str])
4. `ImageGalleryBlock` — type="image_gallery", images (list[ImageItem]), layout_style (Literal["grid", "carousel", "masonry"], default="grid")
5. `PullQuoteBlock` — type="pull_quote", quote (str), attribution (str | None)
6. `ProductShowcaseBlock` — type="product_showcase", products (list[ProductItem])
7. `CelebFeatureBlock` — type="celeb_feature", celebs (list[CelebItem])
8. `DividerBlock` — type="divider", style (Literal["line", "space", "ornament"], default="line")
9. `HashtagBarBlock` — type="hashtag_bar", hashtags (list[str])
10. `CreditsBlock` — type="credits", entries (list[CreditEntry])

**Supporting models:**
- `ImageItem` — url (str), alt (str | None), caption (str | None)
- `ProductItem` — product_id (str | None, placeholder for Phase 5 DB linking), name (str), brand (str | None), image_url (str | None), description (str | None)
- `CelebItem` — celeb_id (str | None, placeholder for Phase 5 DB linking), name (str), image_url (str | None), description (str | None)
- `CreditEntry` — role (str), name (str)

**Union block type:**
- `LayoutBlock = HeroBlock | HeadlineBlock | BodyTextBlock | ImageGalleryBlock | PullQuoteBlock | ProductShowcaseBlock | CelebFeatureBlock | DividerBlock | HashtagBarBlock | CreditsBlock`
- Each block has a `type` field as a Literal discriminator. Use `Annotated[LayoutBlock, Field(discriminator="type")]` for the union.

**Container model:**
- `MagazineLayout(BaseModel)` — schema_version (str, default="1.0"), title (str), subtitle (str | None), keyword (str), blocks (list[Annotated[LayoutBlock, Field(discriminator="type")]]), created_at (str | None), metadata (list[KeyValuePair], default_factory=list)
- `KeyValuePair` — key (str), value (str). Use list[KeyValuePair] instead of dict[str, str] to avoid Gemini compatibility issues (research warning about dict[str, str]).

**Default template factory:**
- `def create_default_template(keyword: str, title: str) -> MagazineLayout` — returns a minimal valid layout with hero, headline, body_text, divider, product_showcase (empty), celeb_feature (empty), hashtag_bar, credits blocks. This is the fallback when Nano Banana fails.

**IMPORTANT:** Do NOT use dict[str, str] anywhere in models — Gemini has known issues with this type. Use list[KeyValuePair] pattern instead.

Update `src/editorial_ai/models/__init__.py` to export the new layout models.
  </action>
  <verify>
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run python -c "from editorial_ai.models.layout import MagazineLayout, LayoutBlock, create_default_template; t = create_default_template('test', 'Test Title'); print(t.model_dump_json(indent=2)[:200])"`
Confirm: imports work, JSON serialization succeeds, schema_version is "1.0"
  </verify>
  <done>MagazineLayout and all 10 block types are importable, JSON-serializable, and the default template factory produces a valid layout.</done>
</task>

<task type="auto">
  <name>Task 2: Editorial content model and validation tests</name>
  <files>src/editorial_ai/models/editorial.py, tests/test_editorial_models.py</files>
  <action>
Create `src/editorial_ai/models/editorial.py` with the editorial content model used as the intermediate output before layout mapping:

- `EditorialContent(BaseModel)` — keyword (str), title (str), subtitle (str | None), body_paragraphs (list[str]), pull_quotes (list[str], default_factory=list), product_mentions (list[ProductMention], default_factory=list), celeb_mentions (list[CelebMention], default_factory=list), hashtags (list[str], default_factory=list), credits (list[CreditEntry], default_factory=list, reuse from layout.py)
- `ProductMention` — name (str), brand (str | None), context (str, how it relates to the editorial)
- `CelebMention` — name (str), context (str, how they relate to the editorial)

This is the model Gemini generates directly (content-only, no layout). The layout is determined separately by Nano Banana or template fallback.

Create `tests/test_editorial_models.py` with tests:

1. `test_magazine_layout_valid_roundtrip` — create a MagazineLayout with multiple block types, serialize to JSON, deserialize back, assert equality
2. `test_block_discriminator_works` — create a list of mixed blocks, validate they serialize/deserialize with correct type discriminators
3. `test_default_template_structure` — call create_default_template(), verify it has expected block types (hero, headline, body_text, etc.)
4. `test_default_template_has_schema_version` — verify schema_version="1.0"
5. `test_editorial_content_valid` — create EditorialContent with all fields, validate it round-trips
6. `test_editorial_content_minimal` — create EditorialContent with only required fields (keyword, title, body_paragraphs), verify defaults are empty lists
7. `test_layout_rejects_invalid_block_type` — verify ValidationError when block has wrong/missing type discriminator
8. `test_headline_level_range` — verify HeadlineBlock rejects level < 1 or > 3

Run all tests with `uv run pytest tests/test_editorial_models.py -v`.
  </action>
  <verify>
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run pytest tests/test_editorial_models.py -v`
Confirm: All 8 tests pass.
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run ruff check src/editorial_ai/models/layout.py src/editorial_ai/models/editorial.py`
Confirm: No lint errors.
  </verify>
  <done>All model tests pass, lint clean. MagazineLayout schema validates correctly with discriminated union blocks, and EditorialContent captures content generation output.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_editorial_models.py -v` — all 8 tests pass
2. `uv run ruff check src/editorial_ai/models/` — no lint errors
3. `uv run python -c "from editorial_ai.models.layout import MagazineLayout; print(MagazineLayout.model_json_schema())"` — JSON schema output is valid
4. `uv run python -c "from editorial_ai.models.editorial import EditorialContent; print(EditorialContent.model_json_schema())"` — JSON schema output is valid
</verification>

<success_criteria>
- MagazineLayout Pydantic model with 10 block types, discriminated union, schema_version field
- EditorialContent model for intermediate content generation output
- Default template factory produces valid fallback layout
- All 8 unit tests pass
- Models are JSON-serializable and Gemini-compatible (no dict[str, str])
</success_criteria>

<output>
After completion, create `.planning/phases/04-editorial-agent-generation-layout/04-01-SUMMARY.md`
</output>
