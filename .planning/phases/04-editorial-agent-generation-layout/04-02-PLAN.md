---
phase: 04-editorial-agent-generation-layout
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/editorial_ai/services/editorial_service.py
  - src/editorial_ai/prompts/editorial.py
  - src/editorial_ai/config.py
  - tests/test_editorial_service.py
autonomous: true

must_haves:
  truths:
    - "EditorialService generates EditorialContent from keyword + curation context via Gemini structured output"
    - "EditorialService generates layout image via Nano Banana (Gemini 2.5 Flash image model)"
    - "EditorialService parses layout image to MagazineLayout structure via Vision AI"
    - "When Nano Banana or Vision parsing fails, the service falls back to default template"
    - "Output repair loop retries Gemini when Pydantic validation fails"
    - "Full pipeline merges EditorialContent into MagazineLayout blocks"
  artifacts:
    - path: "src/editorial_ai/services/editorial_service.py"
      provides: "EditorialService with generate_content, generate_layout_image, parse_layout_image, merge_content_layout, create_editorial"
      contains: "EditorialService"
    - path: "src/editorial_ai/prompts/editorial.py"
      provides: "Prompt templates for content generation, layout parsing, output repair"
      contains: "build_content_generation_prompt"
    - path: "tests/test_editorial_service.py"
      provides: "Unit tests for EditorialService with mocked Gemini calls"
      contains: "test_generate_content"
  key_links:
    - from: "src/editorial_ai/services/editorial_service.py"
      to: "src/editorial_ai/models/editorial.py"
      via: "imports EditorialContent for structured output"
      pattern: "from editorial_ai.models.editorial import"
    - from: "src/editorial_ai/services/editorial_service.py"
      to: "src/editorial_ai/models/layout.py"
      via: "imports MagazineLayout, create_default_template"
      pattern: "from editorial_ai.models.layout import"
    - from: "src/editorial_ai/services/editorial_service.py"
      to: "google.genai"
      via: "native SDK for structured output, image gen, vision"
      pattern: "from google import genai"
---

<objective>
Build the EditorialService that implements the 3-step editorial pipeline: (1) generate editorial content via Gemini structured output, (2) generate layout design image via Nano Banana, (3) parse layout image to JSON via Vision AI, then merge content into layout. Includes output repair loop and template fallback.

Purpose: This is the core business logic of Phase 4 — transforming curated keywords into structured Magazine Layout JSON. The service handles all Gemini API interactions and failure recovery.
Output: EditorialService class, prompt templates, config extensions, and comprehensive unit tests with mocked API calls.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

# Schema from Plan 01
@src/editorial_ai/models/layout.py
@src/editorial_ai/models/editorial.py

# Existing service pattern (follow this structure)
@src/editorial_ai/services/curation_service.py

# Existing prompt pattern
@src/editorial_ai/prompts/curation.py

# Config
@src/editorial_ai/config.py

# Research
@.planning/phases/04-editorial-agent-generation-layout/04-RESEARCH.md
@.planning/phases/04-editorial-agent-generation-layout/04-CONTEXT.md

# Prior summary
@.planning/phases/04-editorial-agent-generation-layout/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Editorial prompts and config extension</name>
  <files>src/editorial_ai/prompts/editorial.py, src/editorial_ai/config.py</files>
  <action>
Create `src/editorial_ai/prompts/editorial.py` with prompt builder functions:

1. `build_content_generation_prompt(keyword: str, trend_context: str) -> str`
   - Instructs Gemini to generate an editorial article in Korean (~500 chars)
   - Input: keyword + trend background from curation phase
   - Output format: JSON matching EditorialContent schema
   - Tone: 패션 매거진 에디터 (sophisticated, informative, engaging)
   - Include: title, subtitle, body_paragraphs (2-3 short paragraphs), pull_quotes (1-2), product_mentions, celeb_mentions, hashtags
   - Celeb/product mentions are text-only placeholders (Phase 5 fills DB IDs)
   - Instruct to output ONLY valid JSON, no markdown fences

2. `build_layout_image_prompt(keyword: str, title: str, num_sections: int) -> str`
   - Instructs Nano Banana (Gemini image model) to generate a magazine layout design
   - Describes: "패션 매거진 레이아웃 디자인" with sections for hero, body, product showcase, etc.
   - Specifies the number of content sections
   - Requests clean, minimalist fashion magazine aesthetic
   - Note: This prompt generates an IMAGE, not text

3. `build_layout_parsing_prompt(keyword: str, block_types: list[str]) -> str`
   - Instructs Vision AI to analyze a magazine layout image and extract block structure
   - Input: layout image + list of available block types
   - Output: JSON array of block definitions with type, position order, and sizing hints
   - Instruct to output ONLY valid JSON matching a simplified block sequence

4. `build_output_repair_prompt(model_name: str, raw_json: str, error_message: str) -> str`
   - Sends the malformed JSON + Pydantic validation error to Gemini for correction
   - Instructs to fix ONLY the validation issues without changing content
   - Output: corrected JSON

Update `src/editorial_ai/config.py`:
- Add `nano_banana_model: str = "gemini-2.5-flash-preview-image-generation"` to Settings
- Add `editorial_model: str = "gemini-2.5-flash"` to Settings
- Add `editorial_max_repair_attempts: int = 2` to Settings
  </action>
  <verify>
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run python -c "from editorial_ai.prompts.editorial import build_content_generation_prompt; print(build_content_generation_prompt('Y2K 패션', '레트로 트렌드 부활')[:100])"`
Confirm: prompt renders correctly with keyword and context interpolated.
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run ruff check src/editorial_ai/prompts/editorial.py src/editorial_ai/config.py`
  </verify>
  <done>Four prompt builders and config extensions are in place. Prompts render with correct variable interpolation.</done>
</task>

<task type="auto">
  <name>Task 2: EditorialService implementation</name>
  <files>src/editorial_ai/services/editorial_service.py</files>
  <action>
Create `src/editorial_ai/services/editorial_service.py` following the CurationService pattern (constructor takes genai.Client, uses settings for model names, retry decorator).

**Class: EditorialService**

Constructor: `__init__(self, client: genai.Client, *, content_model: str | None = None, image_model: str | None = None, max_repair_attempts: int | None = None)`
- Uses settings.editorial_model, settings.nano_banana_model, settings.editorial_max_repair_attempts as defaults

**Methods:**

1. `async def generate_content(self, keyword: str, trend_context: str) -> EditorialContent`
   - Calls Gemini with build_content_generation_prompt(), response_mime_type="application/json", temperature=0.7
   - Parses response.text with EditorialContent.model_validate_json()
   - On parse failure, tries _strip_markdown_fences (reuse from curation_service) then repair loop
   - Uses retry_on_api_error decorator (reuse pattern from curation_service)

2. `async def generate_layout_image(self, keyword: str, title: str, num_sections: int) -> bytes | None`
   - Calls Gemini image model with build_layout_image_prompt()
   - config: response_modalities=["IMAGE", "TEXT"], temperature=1.0
   - Extracts image bytes from response.candidates[0].content.parts — find part with inline_data
   - Returns image bytes on success, None on failure
   - Catches all exceptions, logs warning, returns None (caller falls back to template)

3. `async def parse_layout_image(self, image_bytes: bytes, keyword: str) -> list[dict] | None`
   - Calls Gemini Vision with the layout image + build_layout_parsing_prompt()
   - Sends image as types.Part.from_bytes(data=image_bytes, mime_type="image/png")
   - config: response_mime_type="application/json", temperature=0.0
   - Parses JSON array of block definitions: [{"type": "hero", "order": 0}, {"type": "body_text", "order": 1}, ...]
   - Returns parsed list on success, None on failure

4. `async def repair_output(self, model_class_name: str, raw_json: str, error_msg: str) -> str`
   - Calls Gemini with build_output_repair_prompt(), response_mime_type="application/json", temperature=0.0
   - Returns corrected JSON string
   - Single attempt, no retry (caller manages retry count)

5. `async def _validate_with_repair(self, raw_json: str, model_cls: type, model_name: str) -> Any`
   - Attempts model_cls.model_validate_json(raw_json)
   - On ValidationError: loops up to max_repair_attempts, calling repair_output each time
   - Returns validated model instance or raises last ValidationError

6. `def merge_content_into_layout(self, content: EditorialContent, layout: MagazineLayout) -> MagazineLayout`
   - Maps EditorialContent fields into MagazineLayout blocks
   - For each block in layout.blocks by type:
     - hero: set overlay_title = content.title, overlay_subtitle = content.subtitle
     - headline: set text = content.title
     - body_text: set paragraphs = content.body_paragraphs
     - pull_quote: fill from content.pull_quotes (first match)
     - product_showcase: populate products from content.product_mentions
     - celeb_feature: populate celebs from content.celeb_mentions
     - hashtag_bar: set hashtags = content.hashtags
     - credits: set entries = content.credits
   - Returns new MagazineLayout (don't mutate input)

7. `async def create_editorial(self, keyword: str, trend_context: str) -> MagazineLayout`
   - Full pipeline entry point:
     a. Generate content via generate_content()
     b. Try generate_layout_image() — if succeeds, parse_layout_image()
     c. If layout image OR parsing fails: use create_default_template(keyword, content.title)
     d. If layout image AND parsing succeed: build MagazineLayout from parsed blocks
     e. Merge content into layout via merge_content_into_layout()
     f. Return final MagazineLayout
   - This is the method called by the LangGraph editorial node

**Reuse patterns from curation_service.py:**
- `_strip_markdown_fences()` — import or copy
- `retry_on_api_error` decorator
- `get_genai_client()` factory

**IMPORTANT design notes:**
- Use native google-genai SDK (NOT langchain-google-genai), same as curation_service
- response.parsed is NOT available — always use response.text + model_validate_json()
- For image generation: response_modalities=["IMAGE", "TEXT"] on Gemini 2.5 Flash image model
- For vision parsing: pass image as Part.from_bytes() in contents list alongside text prompt
  </action>
  <verify>
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run python -c "from editorial_ai.services.editorial_service import EditorialService; print('import ok')"`
Confirm: imports work without errors.
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run ruff check src/editorial_ai/services/editorial_service.py`
  </verify>
  <done>EditorialService implements full 3-step pipeline: content gen -> layout image -> vision parse -> merge, with repair loop and template fallback.</done>
</task>

<task type="auto">
  <name>Task 3: EditorialService unit tests</name>
  <files>tests/test_editorial_service.py</files>
  <action>
Create `tests/test_editorial_service.py` with unit tests using mocked Gemini API calls (follow test_curation_service.py patterns — mock the client.aio.models.generate_content method).

**Tests:**

1. `test_generate_content_success` — mock Gemini to return valid EditorialContent JSON, verify parsed model fields
2. `test_generate_content_with_repair` — mock Gemini to return invalid JSON first, then valid corrected JSON on repair call; verify repair loop works (2 generate_content calls total: original + repair)
3. `test_generate_layout_image_success` — mock Gemini to return response with inline_data image part, verify bytes returned
4. `test_generate_layout_image_failure_returns_none` — mock Gemini to raise exception, verify None returned (not raised)
5. `test_parse_layout_image_success` — mock Vision response with JSON block array, verify parsed list
6. `test_parse_layout_image_failure_returns_none` — mock failure, verify None returned
7. `test_merge_content_into_layout` — create EditorialContent and default template, call merge, verify blocks are populated with content
8. `test_create_editorial_full_pipeline` — mock all 3 Gemini calls (content, image, vision), verify final MagazineLayout has content merged into vision-parsed layout
9. `test_create_editorial_nano_banana_fallback` — mock content success, image failure; verify fallback to default template with content merged
10. `test_create_editorial_vision_parse_fallback` — mock content success, image success, vision parse failure; verify fallback to default template

**Mock setup pattern (from test_curation_service.py):**
- Create MagicMock for genai.Client
- Mock `client.aio.models.generate_content` as AsyncMock
- Configure return_value with mock response objects that have .text, .candidates attributes
- For image response: mock inline_data part with .data = b"fake_image_bytes", .mime_type = "image/png"

Run all tests with `uv run pytest tests/test_editorial_service.py -v`.
  </action>
  <verify>
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run pytest tests/test_editorial_service.py -v`
Confirm: All 10 tests pass.
Run: `cd /Users/kiyeol/development/decoded/editorial-ai-worker && uv run ruff check tests/test_editorial_service.py`
  </verify>
  <done>All 10 EditorialService unit tests pass with mocked Gemini API calls. Coverage includes success paths, repair loop, and all fallback scenarios.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_editorial_service.py -v` — all 10 tests pass
2. `uv run ruff check src/editorial_ai/services/editorial_service.py src/editorial_ai/prompts/editorial.py` — no lint errors
3. `uv run pytest tests/ -v` — all existing tests still pass (no regressions)
</verification>

<success_criteria>
- EditorialService.create_editorial() takes keyword + trend_context, returns valid MagazineLayout
- Gemini structured output generates EditorialContent
- Nano Banana generates layout image, Vision AI parses it to block structure
- Fallback to default template when Nano Banana or Vision fails
- Output repair loop retries on Pydantic validation errors
- All 10 unit tests pass with mocked API calls
</success_criteria>

<output>
After completion, create `.planning/phases/04-editorial-agent-generation-layout/04-02-SUMMARY.md`
</output>
