---
phase: 01-graph-skeleton-llm-integration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/editorial_ai/state.py
  - src/editorial_ai/nodes/__init__.py
  - src/editorial_ai/nodes/stubs.py
  - src/editorial_ai/graph.py
  - tests/test_graph.py
autonomous: true

must_haves:
  truths:
    - "graph.compile() 호출 시 에러 없이 CompiledGraph 객체가 반환된다"
    - "stub 노드로 그래프를 invoke하면 curation -> source -> editorial -> review -> admin_gate -> publish 순서로 실행되어 published 상태에 도달한다"
    - "review에서 fail 시 editorial로 되돌아가고, revision_count가 3 이상이면 END로 종료된다"
    - "admin_gate에서 revision_requested 시 editorial로 되돌아간다"
  artifacts:
    - path: "src/editorial_ai/state.py"
      provides: "EditorialPipelineState TypedDict 정의"
      contains: "EditorialPipelineState"
    - path: "src/editorial_ai/graph.py"
      provides: "StateGraph 정의 및 compile"
      exports: ["graph", "builder"]
    - path: "src/editorial_ai/nodes/stubs.py"
      provides: "모든 stub 노드 함수"
      exports: ["stub_curation", "stub_editorial", "stub_review", "stub_admin_gate", "stub_publish"]
    - path: "tests/test_graph.py"
      provides: "그래프 컴파일 및 실행 테스트"
      contains: "test_graph_compiles"
  key_links:
    - from: "src/editorial_ai/graph.py"
      to: "src/editorial_ai/state.py"
      via: "StateGraph(EditorialPipelineState)"
      pattern: "StateGraph\\(EditorialPipelineState\\)"
    - from: "src/editorial_ai/graph.py"
      to: "src/editorial_ai/nodes/stubs.py"
      via: "add_node imports"
      pattern: "from editorial_ai\\.nodes"
    - from: "src/editorial_ai/graph.py"
      to: "review conditional edge"
      via: "add_conditional_edges after review"
      pattern: "add_conditional_edges.*review"
---

<objective>
LangGraph StateGraph를 lean state schema, stub nodes, conditional edges로 정의하여 컴파일 가능한 그래프 스켈레톤을 구축한다.

Purpose: 전체 파이프라인의 토폴로지를 확립하고, 후속 Phase에서 stub을 실제 구현으로 교체하는 기반을 만든다.
Output: EditorialPipelineState TypedDict, stub 노드 6개, conditional edges 2개 (review/admin), 컴파일된 그래프, 테스트
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-graph-skeleton-llm-integration/01-RESEARCH.md
@.planning/phases/01-graph-skeleton-llm-integration/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: State schema and stub nodes</name>
  <files>src/editorial_ai/state.py, src/editorial_ai/nodes/__init__.py, src/editorial_ai/nodes/stubs.py</files>
  <action>
    Lean state schema와 stub 노드를 정의한다.

    1. src/editorial_ai/state.py 생성 - EditorialPipelineState TypedDict:
       ```python
       from typing import TypedDict, Annotated, Optional, Literal
       import operator

       class EditorialPipelineState(TypedDict):
           """파이프라인 공유 상태. Lean 원칙: ID/참조만, 페이로드는 외부 저장."""

           # Curation Phase
           curation_input: dict                  # 트리거 파라미터 (week, filters)
           curated_topics: list[dict]            # [{celeb_id, product_id, angle, trend_keywords}]

           # Source Phase
           enriched_contexts: list[dict]         # [{topic, sources, facts}]

           # Editorial Phase
           current_draft_id: Optional[str]       # Supabase draft row ID (lean: ID만)
           tool_calls_log: Annotated[list[dict], operator.add]  # 누적: tool 사용 로그

           # Review Phase
           review_result: Optional[dict]         # {passed, feedback, scores}
           revision_count: int                   # 피드백 루프 카운터
           feedback_history: Annotated[list[dict], operator.add]  # 누적: 리뷰 피드백

           # Admin Gate
           admin_decision: Optional[Literal["approved", "rejected", "revision_requested"]]
           admin_feedback: Optional[str]

           # Pipeline Meta
           pipeline_status: Literal[
               "curating", "sourcing", "drafting", "reviewing",
               "awaiting_approval", "published", "failed"
           ]
           error_log: Annotated[list[str], operator.add]  # 누적: 에러 로그
       ```

       핵심 원칙:
       - `Annotated[list, operator.add]`: 누적 필요한 필드만 (error_log, tool_calls_log, feedback_history)
       - 나머지: last-write-wins (기본값)
       - full payload는 저장하지 않고 ID/참조만 (current_draft_id 등)

    2. src/editorial_ai/nodes/__init__.py 생성: 빈 파일

    3. src/editorial_ai/nodes/stubs.py 생성 - 6개 stub 노드:
       - `stub_curation`: pipeline_status를 "sourcing"으로, curated_topics를 빈 리스트로 반환
       - `stub_source`: pipeline_status를 "drafting"으로, enriched_contexts를 빈 리스트로 반환
       - `stub_editorial`: pipeline_status를 "reviewing"으로, current_draft_id를 None으로 반환
       - `stub_review`: pipeline_status를 "awaiting_approval"로, review_result를 {"passed": True}로 반환
       - `stub_admin_gate`: pipeline_status를 "published"로, admin_decision을 "approved"로 반환
       - `stub_publish`: pipeline_status를 "published"로 반환

       각 stub은 `(state: EditorialPipelineState) -> dict` 시그니처. 반환값은 업데이트할 필드만 포함하는 dict.
       각 stub에 docstring으로 "Stub: Phase N에서 구현" 명시.

    주의사항:
    - state에 `messages: Annotated[list, add_messages]`를 넣지 않는다. 각 노드가 독립적 LLM 컨텍스트 사용.
    - state에 긴 텍스트(article content 등)를 직접 저장하지 않는다 (lean state 원칙).
  </action>
  <verify>
    - `uv run python -c "from editorial_ai.state import EditorialPipelineState; print('State OK')"` 성공
    - `uv run python -c "from editorial_ai.nodes.stubs import stub_curation, stub_review; print('Stubs OK')"` 성공
    - `uv run ruff check src/editorial_ai/state.py src/editorial_ai/nodes/`
  </verify>
  <done>EditorialPipelineState TypedDict가 lean 원칙으로 정의되고, 6개 stub 노드가 올바른 시그니처로 생성되었다</done>
</task>

<task type="auto">
  <name>Task 2: StateGraph definition, conditional edges, compile, and tests</name>
  <files>src/editorial_ai/graph.py, tests/test_graph.py</files>
  <action>
    StateGraph를 구성하고 컴파일한 뒤 테스트로 검증한다.

    1. src/editorial_ai/graph.py 생성:
       - StateGraph(EditorialPipelineState)로 빌더 생성
       - 6개 stub 노드 등록: curation, source, editorial, review, admin_gate, publish
       - 순차 edges: START -> curation -> source -> editorial -> review
       - review 이후 conditional edge (route_after_review 함수):
         - review_result.passed == True → "admin_gate"
         - revision_count >= 3 → END (실패 종료)
         - 그 외 → "editorial" (재시도, revision_count += 1은 review 노드에서 처리)
       - admin_gate 이후 conditional edge (route_after_admin 함수):
         - admin_decision == "approved" → "publish"
         - admin_decision == "revision_requested" → "editorial"
         - 그 외 (rejected) → END
       - publish -> END
       - `graph = builder.compile()` 으로 컴파일
       - module-level에서 `builder`와 `graph` 모두 export

    2. tests/test_graph.py 생성:
       ```python
       # test_graph_compiles: graph가 None이 아닌지, CompiledGraph 타입인지 확인
       # test_graph_happy_path: 초기 상태로 invoke → pipeline_status == "published"
       # test_graph_review_fail_then_pass: review_result.passed=False stub → editorial 재실행 확인
       # test_graph_max_retries: revision_count >= 3일 때 END로 종료 확인
       ```

       happy path 테스트의 초기 상태:
       ```python
       initial_state = {
           "curation_input": {"week": "2026-W08"},
           "curated_topics": [],
           "enriched_contexts": [],
           "current_draft_id": None,
           "tool_calls_log": [],
           "review_result": None,
           "revision_count": 0,
           "feedback_history": [],
           "admin_decision": None,
           "admin_feedback": None,
           "pipeline_status": "curating",
           "error_log": [],
       }
       ```

       review fail 테스트는 stub_review를 monkeypatch하여 첫 호출 시 {"passed": False} 반환, 이후 {"passed": True} 반환하도록 구성. 또는 그래프를 별도 빌드하여 review 노드를 커스텀 함수로 교체.

       max retries 테스트는 revision_count=3, review_result={"passed": False}인 상태에서 review 노드 이후 END로 가는지 확인.

    주의사항:
    - `MemorySaver`를 compile에 사용하지 않는다 (테스트에서도 불필요, stateless invoke로 충분)
    - conditional edge의 반환값은 노드 이름 문자열이어야 한다
    - route_after_review에서 revision_count 체크를 반드시 포함하여 무한루프 방지
  </action>
  <verify>
    - `uv run pytest tests/test_graph.py -v` 모든 테스트 통과
    - `uv run python -c "from editorial_ai.graph import graph; print(type(graph))"` → CompiledStateGraph 타입
    - `uv run ruff check src/editorial_ai/graph.py tests/test_graph.py`
  </verify>
  <done>StateGraph가 6개 노드 + 2개 conditional edge로 컴파일되고, happy path / review fail / max retries 테스트가 모두 통과한다</done>
</task>

</tasks>

<verification>
```bash
# 1. 전체 테스트 실행
uv run pytest tests/test_graph.py -v

# 2. 그래프 컴파일 확인
uv run python -c "
from editorial_ai.graph import graph
print(f'Graph type: {type(graph).__name__}')
print(f'Nodes: {list(graph.nodes.keys()) if hasattr(graph, \"nodes\") else \"N/A\"}')
print('Graph compilation: OK')
"

# 3. Happy path 실행 확인
uv run python -c "
from editorial_ai.graph import graph
result = graph.invoke({
    'curation_input': {'week': '2026-W08'},
    'curated_topics': [],
    'enriched_contexts': [],
    'current_draft_id': None,
    'tool_calls_log': [],
    'review_result': None,
    'revision_count': 0,
    'feedback_history': [],
    'admin_decision': None,
    'admin_feedback': None,
    'pipeline_status': 'curating',
    'error_log': [],
})
assert result['pipeline_status'] == 'published', f'Expected published, got {result[\"pipeline_status\"]}'
print('Happy path: OK')
"

# 4. 린트
uv run ruff check src/ tests/
```
</verification>

<success_criteria>
1. graph.compile() 에러 없이 성공
2. Happy path invoke → pipeline_status == "published"
3. Review fail → editorial 재실행 확인
4. Max retries (revision_count >= 3) → 그래프 종료 확인
5. 모든 테스트 통과, ruff check 통과
</success_criteria>

<output>
After completion, create `.planning/phases/01-graph-skeleton-llm-integration/01-02-SUMMARY.md`
</output>
