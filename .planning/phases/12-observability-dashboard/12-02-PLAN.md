---
phase: 12-observability-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - admin/src/components/pipeline/pipeline-tab.tsx
  - admin/src/components/pipeline/timeline-bar.tsx
  - admin/src/components/pipeline/node-detail-panel.tsx
  - admin/src/components/pipeline/cost-summary-card.tsx
  - admin/src/components/content-tabs.tsx
  - admin/src/app/contents/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Pipeline tab shows a Gantt-style horizontal bar chart with one bar per node run"
    - "Each bar width is proportional to duration_ms relative to total pipeline duration"
    - "Clicking a bar expands a detail panel below showing tokens, LLM call count, errors, and IO data"
    - "NodeDetailPanel header shows LLM call count derived from node.token_usage.length"
    - "Cost summary card at the top shows total duration, total tokens (input+output split), estimated cost, and node count"
    - "Review retry rounds are visually separated with round dividers"
    - "Error nodes show red bars with alert icons"
    - "Empty state shown when no logs available"
    - "IO data lazy-loaded on first node expand (re-fetch with include_io=true)"
    - "ContentTabs has three tabs: Magazine, JSON, Pipeline"
    - "Detail page fetches logs alongside content and passes to ContentTabs"
  artifacts:
    - path: "admin/src/components/pipeline/pipeline-tab.tsx"
      provides: "Pipeline tab container with summary + timeline + detail"
      contains: "PipelineTab"
    - path: "admin/src/components/pipeline/timeline-bar.tsx"
      provides: "Single Gantt bar component for one node"
      contains: "TimelineBar"
    - path: "admin/src/components/pipeline/node-detail-panel.tsx"
      provides: "Expandable detail panel for selected node"
      contains: "NodeDetailPanel"
    - path: "admin/src/components/pipeline/cost-summary-card.tsx"
      provides: "Summary card with cost, tokens, duration"
      contains: "CostSummaryCard"
    - path: "admin/src/components/content-tabs.tsx"
      provides: "Updated tabs with Pipeline tab"
      contains: "Pipeline"
    - path: "admin/src/app/contents/[id]/page.tsx"
      provides: "Detail page fetching logs data"
      contains: "LogsResponse"
  key_links:
    - from: "admin/src/app/contents/[id]/page.tsx"
      to: "admin/src/components/content-tabs.tsx"
      via: "Page passes logs data to ContentTabs"
    - from: "admin/src/components/content-tabs.tsx"
      to: "admin/src/components/pipeline/pipeline-tab.tsx"
      via: "Pipeline tab rendered inside ContentTabs"
    - from: "admin/src/components/pipeline/pipeline-tab.tsx"
      to: "admin/src/components/pipeline/timeline-bar.tsx"
      via: "PipelineTab renders TimelineBar for each node"
    - from: "admin/src/components/pipeline/pipeline-tab.tsx"
      to: "admin/src/components/pipeline/node-detail-panel.tsx"
      via: "PipelineTab renders NodeDetailPanel for selected node"
    - from: "admin/src/components/pipeline/pipeline-tab.tsx"
      to: "admin/src/components/pipeline/cost-summary-card.tsx"
      via: "PipelineTab renders CostSummaryCard at top"
---

<objective>
Build the Pipeline tab with Gantt-style timeline visualization, expandable node detail panels, and cost summary card. Wire it into the existing content detail page.

Purpose: This is the core deliverable of Phase 12 — administrators can visually trace pipeline execution, see per-node timing and token usage, and understand cost implications at a glance.
Output: Working Pipeline tab on the content detail page with timeline, drill-down details, and cost summary.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-observability-dashboard/12-CONTEXT.md
@.planning/phases/12-observability-dashboard/12-RESEARCH.md
@.planning/phases/12-observability-dashboard/12-01-SUMMARY.md
@admin/src/components/content-tabs.tsx
@admin/src/app/contents/[id]/page.tsx
@admin/src/lib/types.ts
@admin/src/lib/api.ts
@admin/src/components/pipeline/cost-utils.ts
@admin/src/components/ui/card.tsx
@admin/src/components/ui/badge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pipeline components (CostSummaryCard + TimelineBar + NodeDetailPanel)</name>
  <files>
    admin/src/components/pipeline/cost-summary-card.tsx
    admin/src/components/pipeline/timeline-bar.tsx
    admin/src/components/pipeline/node-detail-panel.tsx
  </files>
  <action>
**Create `admin/src/components/pipeline/cost-summary-card.tsx`:**

A summary card showing 4 metrics in a grid: Total Duration, Total Tokens (with input/output split), Estimated Cost, and Node Count with status badge.

```typescript
"use client";

import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { estimateCost, formatCost, formatDuration, formatNumber } from "./cost-utils";
import type { PipelineRunSummary, NodeRunLog } from "@/lib/types";
```

Props: `{ summary: PipelineRunSummary; runs: NodeRunLog[] }`

The total cost should be calculated by iterating over all `runs`, then each run's `token_usage` array, calling `estimateCost(tu.prompt_tokens, tu.completion_tokens, tu.model_name)` and summing. This gives per-model-accurate costs.

Layout: 4-column grid on md+, 2-column on mobile.
- Col 1: "Total Duration" — `formatDuration(summary.total_duration_ms)`
- Col 2: "Total Tokens" — `formatNumber(summary.total_tokens)` with subtitle `"formatNumber(in) in + formatNumber(out) out"`
- Col 3: "Estimated Cost" — `formatCost(totalCost)`
- Col 4: "Nodes" — `summary.node_count` with status badge (destructive variant for "failed", default for "completed", secondary for "running")

**Create `admin/src/components/pipeline/timeline-bar.tsx`:**

A single Gantt bar row for one node. Props:
```typescript
interface TimelineBarProps {
  node: NodeRunLog;
  totalDurationMs: number;
  pipelineStartMs: number;
  isSelected: boolean;
  onSelect: (node: NodeRunLog) => void;
}
```

Layout: flex row with:
1. Node name label (fixed width ~28, truncated, `text-xs font-medium`)
2. Flexible bar area (relative container):
   - Background: `bg-muted/30 rounded h-7`
   - Positioned bar inside: `absolute h-full rounded cursor-pointer transition-colors`
   - Bar position: `left = ((nodeStartMs - pipelineStartMs) / totalDurationMs) * 100%`
   - Bar width: `Math.max((node.duration_ms / totalDurationMs) * 100, 1)%` (min 1% so fast nodes are clickable)
   - Color: error -> `bg-red-400 hover:bg-red-500`, success -> `bg-blue-400 hover:bg-blue-500`, selected -> add `ring-2 ring-blue-600`
   - Show duration label inside bar if wide enough (>8%), otherwise next to bar
3. Duration label (fixed width ~16, `text-xs text-muted-foreground text-right`)

Compute `nodeStartMs` from `new Date(node.started_at).getTime()`.

For error nodes: prepend an `AlertTriangle` icon (lucide-react, size 3) to the node name in orange/destructive color.

**Create `admin/src/components/pipeline/node-detail-panel.tsx`:**

Expandable detail panel shown below the timeline when a node is selected. Props:
```typescript
interface NodeDetailPanelProps {
  node: NodeRunLog;
  contentId: string;
  onLoadIo: () => Promise<void>;
  ioLoaded: boolean;
}
```

Layout: bordered card with sections:

1. **Header row:** Node name (bold) + status badge + duration + LLM call count (`"LLM Calls: {node.token_usage.length}"` — displayed as a small secondary badge next to the duration)
2. **Token usage section:** For each entry in `node.token_usage`:
   - `"formatNumber(prompt_tokens) input + formatNumber(completion_tokens) output = formatNumber(total_tokens) tokens"`
   - Model name if present
   - Per-entry estimated cost
3. **Node totals:** `"Total: formatNumber(total_prompt_tokens) in + formatNumber(total_completion_tokens) out = formatNumber(total_tokens) tokens"`
4. **Error section** (conditional, only if `node.error_type`):
   - Red-bordered section
   - Compact: `error_type: first line of error_message`
   - "Show full error" button toggles full `error_message` in monospace `<pre>` block
5. **IO data section** (conditional):
   - If `node.input_state` and `node.output_state` are present: show as collapsible JSON `<pre>` blocks with "Input State" and "Output State" headings
   - If not loaded yet: show "Load IO data" button that calls `onLoadIo()`
   - Visually: `bg-slate-950 text-slate-100 text-xs font-mono` (same styling as JSON tab)

Use `useState` for error expand toggle and IO section expand toggle.
  </action>
  <verify>
1. `cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npx tsc --noEmit --pretty 2>&1 | head -30` — no type errors
2. `cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npm run build 2>&1 | tail -20` — build succeeds
  </verify>
  <done>CostSummaryCard, TimelineBar, and NodeDetailPanel components created with proper typing and styling. NodeDetailPanel shows LLM call count in header.</done>
</task>

<task type="auto">
  <name>Task 2: PipelineTab container + ContentTabs integration + detail page wiring</name>
  <files>
    admin/src/components/pipeline/pipeline-tab.tsx
    admin/src/components/content-tabs.tsx
    admin/src/app/contents/[id]/page.tsx
  </files>
  <action>
**Create `admin/src/components/pipeline/pipeline-tab.tsx`:**

The main Pipeline tab container. This is a "use client" component.

```typescript
"use client";

import { useState, useCallback } from "react";
import type { LogsResponse, NodeRunLog } from "@/lib/types";
```

Props: `{ logs: LogsResponse | null; contentId: string }`

**State:**
- `selectedNode: NodeRunLog | null` — currently expanded node
- `fullLogs: LogsResponse | null` — logs with IO data (lazy-loaded)
- `ioLoading: boolean` — loading indicator for IO fetch

**Empty state:** If `logs` is null or `logs.runs.length === 0`, show a centered message: "No pipeline logs available for this content." with subtle description "Logs are recorded when the pipeline runs."

**Normal rendering flow:**

1. **Round grouping:** Group `logs.runs` by retry round using this algorithm:
   - Iterate through runs in order. When you encounter a `node_name === "editorial"` that has already appeared in the current round, start a new round.
   - Return array of `{ round: number; nodes: NodeRunLog[] }`

2. **Cost summary card** at the top: `<CostSummaryCard summary={logs.summary!} runs={logs.runs} />`

3. **Escalation banner** (conditional): If `logs.summary?.status === "failed"` and the last run with `node_name === "review"` has an `error_message` containing "escalat" (case-insensitive), show an amber banner: "Review escalated: quality gate rejected after maximum retry attempts."

4. **Timeline section per round:**
   - If multiple rounds: show "Round N" divider label before each round's bars
   - For each node in the round: `<TimelineBar>` with totalDurationMs from the round's nodes
   - Calculate `pipelineStartMs` from the earliest `started_at` in the round
   - Calculate `totalDurationMs` from the round's total span (latest ended_at - earliest started_at)

5. **Detail panel:** When `selectedNode` is set, render `<NodeDetailPanel>` below the timeline section. The node's IO data comes from `fullLogs` if loaded, otherwise from `logs`.

**IO lazy loading:**
```typescript
const loadIoData = useCallback(async () => {
  if (fullLogs || ioLoading) return;
  setIoLoading(true);
  try {
    const res = await fetch(`/api/contents/${contentId}/logs?include_io=true`);
    if (res.ok) {
      const data = await res.json();
      setFullLogs(data);
    }
  } finally {
    setIoLoading(false);
  }
}, [contentId, fullLogs, ioLoading]);
```

When `selectedNode` is set and `fullLogs` is available, find the matching node from `fullLogs.runs` (match by `node_name` and `started_at`) and use its `input_state`/`output_state` for the detail panel.

**Update `admin/src/components/content-tabs.tsx`:**

Add the Pipeline tab:

1. Add import: `import { PipelineTab } from "@/components/pipeline/pipeline-tab";`
2. Add import: `import type { LogsResponse } from "@/lib/types";`
3. Extend `ContentTabsProps`:
   ```typescript
   interface ContentTabsProps {
     blocks: LayoutBlock[];
     designSpec: DesignSpec | null;
     layoutJson: unknown;
     logs: LogsResponse | null;    // NEW
     contentId: string;             // NEW
   }
   ```
4. Destructure new props in the component
5. Add a third tab trigger: `<TabsTrigger value="pipeline">Pipeline</TabsTrigger>`
6. Add third tab content:
   ```tsx
   <TabsContent value="pipeline">
     <PipelineTab logs={logs} contentId={contentId} />
   </TabsContent>
   ```

**Update `admin/src/app/contents/[id]/page.tsx`:**

1. Add import: `import type { LogsResponse } from "@/lib/types";`
2. Fetch logs in parallel with content. Replace the single `apiGet` with `Promise.all`:
   ```typescript
   let content: ContentItem;
   let logsData: LogsResponse | null = null;
   try {
     const [contentResult, logsResult] = await Promise.all([
       apiGet<ContentItem>(`/api/contents/${id}`),
       apiGet<LogsResponse>(`/api/contents/${id}/logs?include_io=false`).catch(() => null),
     ]);
     content = contentResult;
     logsData = logsResult;
   } catch (err) {
     // ... existing error handling for content fetch failure
   }
   ```
3. Pass new props to ContentTabs:
   ```tsx
   <ContentTabs
     blocks={blocks}
     designSpec={designSpec}
     layoutJson={content.layout_json}
     logs={logsData}
     contentId={content.id}
   />
   ```

Keep the existing error handling for the content fetch. If the content fetch fails, the whole page errors. If only the logs fetch fails (caught by `.catch(() => null)`), the page renders normally with a null logs prop, and the Pipeline tab shows the empty state.
  </action>
  <verify>
1. `cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npx tsc --noEmit --pretty 2>&1 | head -30` — no type errors
2. `cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npm run build 2>&1 | tail -20` — build succeeds
  </verify>
  <done>PipelineTab with Gantt timeline, round grouping, node detail with IO lazy loading, and cost summary. ContentTabs extended with Pipeline tab. Detail page fetches logs in parallel and passes to tabs.</done>
</task>

</tasks>

<verification>
1. Type check: `cd admin && npx tsc --noEmit` passes
2. Build: `cd admin && npm run build` succeeds
3. Pipeline tab shows cost summary card with duration, tokens, cost, node count
4. Gantt bars render proportional widths with min 1% for fast nodes
5. Clicking a bar expands detail panel with token breakdown
6. Error nodes show red bars with alert icons
7. Empty state when no logs (null or empty runs)
8. IO data lazy-loaded on first expand click
9. Retry rounds visually separated with "Round N" dividers
10. Content + logs fetched in parallel on detail page
</verification>

<success_criteria>
- Pipeline tab shows Gantt-style horizontal bar chart with one bar per node run
- Bars are proportional to duration with color coding (blue=success, red=error)
- Clicking a bar shows node detail: tokens (input+output split), LLM call count, cost, errors, IO data
- Cost summary card shows total pipeline metrics at the top
- Review retry rounds grouped with visual separators
- IO data lazy-loaded on demand (not fetched on page load)
- Empty state for content without pipeline logs
- No TypeScript or build errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-observability-dashboard/12-02-SUMMARY.md`
</output>
