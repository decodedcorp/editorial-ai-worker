---
phase: 12-observability-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - admin/src/components/pipeline-status-indicator.tsx
  - admin/src/components/content-table.tsx
  - admin/src/app/api/contents/route.ts
  - admin/src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "List page table has a Pipeline column showing step dots + text badge for each content item"
    - "Step dots visually indicate pipeline progress based on the content's DB status"
    - "Status mapping: pending = all steps filled (awaiting admin), approved/published = complete, rejected = red"
    - "PipelineStatusIndicator renders step dots (5 dots) + label badge + summary metrics"
    - "List items display total duration, estimated cost, and retry count (locked decision)"
    - "BFF content list proxy merges log summaries by fetching /api/contents/{id}/logs for each item in parallel server-side"
    - "Failed/error state uses red-colored dots"
    - "Mid-pipeline stages (curating/sourcing/drafting/reviewing) are NOT shown on list page because only DB terminal statuses are available without the logs API; fine-grained pipeline progress is reserved for the detail page Pipeline tab"
  artifacts:
    - path: "admin/src/components/pipeline-status-indicator.tsx"
      provides: "Step dots + badge indicator + summary metrics (duration, cost, retries)"
      contains: "PipelineStatusIndicator"
    - path: "admin/src/components/content-table.tsx"
      provides: "Updated table with Pipeline column"
      contains: "pipeline"
    - path: "admin/src/app/api/contents/route.ts"
      provides: "BFF proxy that merges log summaries into content list response"
      contains: "summaries"
    - path: "admin/src/lib/types.ts"
      provides: "ContentItemWithSummary type extending ContentItem with pipeline summary fields"
      contains: "ContentItemWithSummary"
  key_links:
    - from: "admin/src/components/content-table.tsx"
      to: "admin/src/components/pipeline-status-indicator.tsx"
      via: "Table column renders PipelineStatusIndicator"
    - from: "admin/src/app/api/contents/route.ts"
      to: "admin/src/app/api/contents/[id]/logs/route.ts"
      via: "BFF list proxy fetches log summaries per item server-side"
---

<objective>
Add pipeline status indicators to the content list page table. Show step dots with text badges to convey pipeline progress at a glance. Display total duration, estimated cost, and retry count per list item.

Purpose: Administrators can quickly scan the list page and see which contents are in what pipeline stage, plus key execution metrics, without navigating to each detail page. This fulfills the OBS-06 requirement and the locked decision for list item summary info.
Output: Enhanced content table with a Pipeline column showing step dots, status badges, and summary metrics (duration, cost, retries) per row. BFF proxy enriches list response with log summaries server-side.
</objective>

<execution_context>
@/Users/kiyeol/.claude-pers/get-shit-done/workflows/execute-plan.md
@/Users/kiyeol/.claude-pers/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-observability-dashboard/12-CONTEXT.md
@.planning/phases/12-observability-dashboard/12-RESEARCH.md
@.planning/phases/12-observability-dashboard/12-01-SUMMARY.md
@admin/src/components/content-table.tsx
@admin/src/components/content-status-badge.tsx
@admin/src/lib/types.ts
@admin/src/app/api/contents/route.ts
@admin/src/components/pipeline/cost-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: BFF content list enrichment + ContentItemWithSummary type</name>
  <files>
    admin/src/app/api/contents/route.ts
    admin/src/lib/types.ts
  </files>
  <action>
**Update `admin/src/lib/types.ts`:**

Add a new interface after `ContentListResponse` that extends `ContentItem` with optional pipeline summary fields:

```typescript
// ---------------------------------------------------------------------------
// Content item with pipeline summary (enriched by BFF list proxy)
// ---------------------------------------------------------------------------

export interface PipelineSummaryFields {
  total_duration_ms: number | null;
  estimated_cost_usd: number | null;
  retry_count: number;
}

export interface ContentItemWithSummary extends ContentItem {
  pipeline_summary: PipelineSummaryFields | null;
}

export interface ContentListWithSummaryResponse {
  items: ContentItemWithSummary[];
  total: number;
}
```

**Update `admin/src/app/api/contents/route.ts`:**

After fetching the content list from the backend, enrich each item with pipeline summary data by fetching log summaries server-side. This runs on the BFF (server) so it's a single request from the client's perspective.

```typescript
import { NextRequest, NextResponse } from "next/server";
import { API_BASE_URL, ADMIN_API_KEY, DEMO_MODE } from "@/config";
import { getDemoItems } from "@/lib/demo-data";
import { estimateCost } from "@/components/pipeline/cost-utils";

export async function GET(request: NextRequest) {
  const { searchParams } = request.nextUrl;

  if (DEMO_MODE) {
    const status = searchParams.get("status") || undefined;
    const limit = parseInt(searchParams.get("limit") || "20", 10);
    const offset = parseInt(searchParams.get("offset") || "0", 10);
    const items = getDemoItems(status);
    const paged = items.slice(offset, offset + limit);
    // Demo items get null summary
    const enriched = paged.map((item: Record<string, unknown>) => ({ ...item, pipeline_summary: null }));
    return NextResponse.json({ items: enriched, total: items.length });
  }

  const url = new URL("/api/contents", API_BASE_URL);
  for (const key of ["status", "limit", "offset"]) {
    const value = searchParams.get(key);
    if (value) url.searchParams.set(key, value);
  }

  const res = await fetch(url.toString(), {
    cache: "no-store",
    headers: { "X-API-Key": ADMIN_API_KEY },
  });

  if (!res.ok) {
    const data = await res.json();
    return NextResponse.json(data, { status: res.status });
  }

  const data = await res.json();
  const items = data.items ?? [];

  // Fetch log summaries in parallel for all items (server-side, no N+1 from client)
  const summaries = await Promise.all(
    items.map(async (item: { id: string }) => {
      try {
        const logsRes = await fetch(
          `${API_BASE_URL}/api/contents/${item.id}/logs?include_io=false`,
          {
            cache: "no-store",
            headers: { "X-API-Key": ADMIN_API_KEY },
          },
        );
        if (!logsRes.ok) return null;
        const logs = await logsRes.json();
        if (!logs.summary) return null;

        // Calculate estimated cost from individual node runs
        let totalCost = 0;
        for (const run of logs.runs ?? []) {
          for (const tu of run.token_usage ?? []) {
            totalCost += estimateCost(tu.prompt_tokens, tu.completion_tokens, tu.model_name);
          }
        }

        // Count retry rounds: count how many times the "editorial" node appears
        // (first occurrence is the initial run, each subsequent is a retry)
        const editorialRuns = (logs.runs ?? []).filter(
          (r: { node_name: string }) => r.node_name === "editorial"
        ).length;
        const retryCount = Math.max(0, editorialRuns - 1);

        return {
          total_duration_ms: logs.summary.total_duration_ms,
          estimated_cost_usd: totalCost,
          retry_count: retryCount,
        };
      } catch {
        return null;
      }
    }),
  );

  // Merge summaries into items
  const enriched = items.map((item: Record<string, unknown>, i: number) => ({
    ...item,
    pipeline_summary: summaries[i],
  }));

  return NextResponse.json({ items: enriched, total: data.total });
}
```

Key design decisions:
- Log fetches happen server-side in the BFF, in parallel via `Promise.all`. This is a single HTTP request from the browser's perspective.
- Failures are graceful — if a log fetch fails, that item gets `pipeline_summary: null`.
- Retry count is derived from the number of "editorial" node appearances (each retry re-runs the editorial node).
- Cost is calculated using the same `estimateCost` utility from 12-01, ensuring consistency with the detail page.
  </action>
  <verify>
`cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npx tsc --noEmit --pretty 2>&1 | head -30` — no type errors
  </verify>
  <done>BFF content list proxy enriched with pipeline summaries. ContentItemWithSummary type added. Each list item now includes total_duration_ms, estimated_cost_usd, and retry_count.</done>
</task>

<task type="auto">
  <name>Task 2: PipelineStatusIndicator component with summary metrics</name>
  <files>
    admin/src/components/pipeline-status-indicator.tsx
  </files>
  <action>
**Create `admin/src/components/pipeline-status-indicator.tsx`:**

This component shows step dots + a text badge + summary metrics (duration, cost, retries) to indicate pipeline progress.

**Status mapping rationale:** The list page has the content's DB `status` field (pending/approved/rejected/published) for visual status, plus the enriched `pipeline_summary` fields from the BFF for metrics.

- `"pending"` = content reached admin_gate, awaiting approval -> all 5 dots filled (pipeline complete, awaiting human action)
- `"approved"` = approved by admin -> all 5 dots filled + green check style
- `"published"` = published -> all 5 dots filled + published style
- `"rejected"` = rejected by admin -> all 5 dots but last in red style

**Why mid-pipeline stages are not shown:** Fine-grained pipeline stages (curating/sourcing/drafting/reviewing) are only reachable while the pipeline is actively running. Once the pipeline completes, content transitions to a DB terminal status (pending/approved/rejected/published). The list page only shows items with terminal DB statuses. Real-time in-progress pipeline tracking is out of scope (no WebSocket/polling); fine-grained pipeline progress is reserved for the detail page Pipeline tab.

```typescript
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";
import { Check, X } from "lucide-react";
import { formatDuration, formatCost } from "@/components/pipeline/cost-utils";
import type { PipelineSummaryFields } from "@/lib/types";

const TOTAL_STEPS = 5;

interface StatusConfig {
  filledSteps: number;
  label: string;
  dotColor: string;
  badgeVariant: "default" | "secondary" | "destructive" | "outline";
  badgeClassName: string;
  icon?: "check" | "x";
}

const STATUS_MAP: Record<string, StatusConfig> = {
  pending: {
    filledSteps: 5,
    label: "Awaiting Approval",
    dotColor: "bg-amber-400",
    badgeVariant: "secondary",
    badgeClassName: "bg-amber-100 text-amber-800 border-amber-200",
  },
  approved: {
    filledSteps: 5,
    label: "Approved",
    dotColor: "bg-green-500",
    badgeVariant: "default",
    badgeClassName: "bg-green-100 text-green-800 border-green-200",
    icon: "check",
  },
  published: {
    filledSteps: 5,
    label: "Published",
    dotColor: "bg-green-500",
    badgeVariant: "outline",
    badgeClassName: "",
    icon: "check",
  },
  rejected: {
    filledSteps: 5,
    label: "Rejected",
    dotColor: "bg-red-400",
    badgeVariant: "destructive",
    badgeClassName: "",
    icon: "x",
  },
};

interface PipelineStatusIndicatorProps {
  status: string;
  pipelineSummary?: PipelineSummaryFields | null;
}

export function PipelineStatusIndicator({ status, pipelineSummary }: PipelineStatusIndicatorProps) {
  const config = STATUS_MAP[status];
  if (!config) return null;

  return (
    <div className="flex flex-col gap-0.5">
      {/* Row 1: Step dots + badge */}
      <div className="flex items-center gap-2">
        <div className="flex gap-0.5">
          {Array.from({ length: TOTAL_STEPS }, (_, i) => (
            <span
              key={i}
              className={cn(
                "inline-block h-1.5 w-1.5 rounded-full",
                i < config.filledSteps ? config.dotColor : "bg-muted-foreground/20",
              )}
            />
          ))}
        </div>
        <Badge variant={config.badgeVariant} className={cn("text-[10px] px-1.5 py-0", config.badgeClassName)}>
          {config.icon === "check" && <Check className="mr-0.5 size-2.5" />}
          {config.icon === "x" && <X className="mr-0.5 size-2.5" />}
          {config.label}
        </Badge>
      </div>
      {/* Row 2: Summary metrics (duration, cost, retries) */}
      {pipelineSummary && (
        <div className="flex items-center gap-2 text-[10px] text-muted-foreground">
          {pipelineSummary.total_duration_ms != null && (
            <span>{formatDuration(pipelineSummary.total_duration_ms)}</span>
          )}
          {pipelineSummary.estimated_cost_usd != null && (
            <span>{formatCost(pipelineSummary.estimated_cost_usd)}</span>
          )}
          {pipelineSummary.retry_count > 0 && (
            <span className="text-amber-600">
              {pipelineSummary.retry_count} {pipelineSummary.retry_count === 1 ? "retry" : "retries"}
            </span>
          )}
        </div>
      )}
    </div>
  );
}
```

Keep the component compact. Row 1 is the dots + badge (same as before). Row 2 is the new summary metrics line, only shown when `pipelineSummary` is available. The metrics line uses `text-[10px]` and `text-muted-foreground` to stay subordinate to the status badge.
  </action>
  <verify>
`cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npx tsc --noEmit --pretty 2>&1 | head -30` — no type errors
  </verify>
  <done>PipelineStatusIndicator component created with step dots + badge + summary metrics (duration, cost, retries) for all statuses.</done>
</task>

<task type="auto">
  <name>Task 3: Content table Pipeline column + list page wiring</name>
  <files>
    admin/src/components/content-table.tsx
    admin/src/app/contents/page.tsx
  </files>
  <action>
**Update `admin/src/components/content-table.tsx`:**

1. Add imports:
   ```typescript
   import { PipelineStatusIndicator } from "@/components/pipeline-status-indicator";
   import type { ContentItemWithSummary } from "@/lib/types";
   ```

2. Update the table's generic type to use `ContentItemWithSummary` instead of `ContentItem` (the column definitions and `useReactTable` call).

3. Add a new column definition AFTER the existing "status" column (so order is: Title, Status, Pipeline, Keyword, Created):

   ```typescript
   {
     id: "pipeline",
     header: "Pipeline",
     cell: ({ row }) => (
       <PipelineStatusIndicator
         status={row.original.status}
         pipelineSummary={row.original.pipeline_summary}
       />
     ),
     enableSorting: false,
   },
   ```

4. The column is placed between "Status" and "Keyword" in the `columns` array.

**Update `admin/src/app/contents/page.tsx`:**

If the list page fetches data using `ContentListResponse`, update it to use `ContentListWithSummaryResponse` type instead (since the BFF now returns enriched items). Check the existing import and update accordingly:

```typescript
import type { ContentListWithSummaryResponse } from "@/lib/types";
```

And update the `apiGet` call to use the new response type.
  </action>
  <verify>
1. `cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npx tsc --noEmit --pretty 2>&1 | head -30` — no type errors
2. `cd /Users/kiyeol/development/decoded/editorial-ai-worker/admin && npm run build 2>&1 | tail -20` — build succeeds
  </verify>
  <done>Content table enhanced with Pipeline column showing step dots, status badges, and summary metrics per content item. List page wired to use enriched response type.</done>
</task>

</tasks>

<verification>
1. Type check: `cd admin && npx tsc --noEmit` passes
2. Build: `cd admin && npm run build` succeeds
3. List page table shows 5 columns: Title, Status, Pipeline, Keyword, Created
4. Pipeline column shows step dots + badge for each content item
5. Pipeline column shows total duration, estimated cost, and retry count below the badge when summary data is available
6. BFF content list proxy fetches log summaries server-side in parallel (single HTTP request from browser)
7. Graceful degradation: items with no logs show dots + badge only (no metrics row)
8. Different statuses show different visual treatment (amber for pending, green for approved, red for rejected)
</verification>

<success_criteria>
- Content list page shows Pipeline column with step dots, text badge, and summary metrics
- Step dots indicate pipeline progress based on DB status
- Total duration, estimated cost, and retry count displayed per list item (locked decision fulfilled)
- BFF enriches list response server-side — single HTTP request from the client, no N+1 from browser
- Visual distinction between pending (amber), approved (green), rejected (red), published states
- Mid-pipeline stages not shown on list page (only DB terminal statuses available; fine-grained progress on detail page Pipeline tab)
- Component is compact enough to fit in table rows
- No TypeScript or build errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-observability-dashboard/12-03-SUMMARY.md`
</output>
